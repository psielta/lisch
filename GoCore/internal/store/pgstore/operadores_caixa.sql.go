// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: operadores_caixa.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const contarOperadoresAtivos = `-- name: ContarOperadoresAtivos :one
SELECT COUNT(*) as total_operadores
FROM public.operadores_caixa
WHERE tenant_id = $1
  AND deleted_at IS NULL
  AND ativo = 1
`

func (q *Queries) ContarOperadoresAtivos(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, contarOperadoresAtivos, tenantID)
	var total_operadores int64
	err := row.Scan(&total_operadores)
	return total_operadores, err
}

const createNewOperador = `-- name: CreateNewOperador :one
SELECT upsert_operador_caixa FROM public.upsert_operador_caixa(
    $1,
    $2, 
    $3,
    NULL,
    1
)
`

type CreateNewOperadorParams struct {
	PTenantID  uuid.UUID `json:"p_tenant_id"`
	PIDUsuario uuid.UUID `json:"p_id_usuario"`
	PNome      string    `json:"p_nome"`
}

func (q *Queries) CreateNewOperador(ctx context.Context, arg CreateNewOperadorParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, createNewOperador, arg.PTenantID, arg.PIDUsuario, arg.PNome)
	var upsert_operador_caixa interface{}
	err := row.Scan(&upsert_operador_caixa)
	return upsert_operador_caixa, err
}

const desativarOperador = `-- name: DesativarOperador :one
UPDATE public.operadores_caixa 
SET deleted_at = now(),
    updated_at = now()
WHERE id_usuario = $1 
  AND tenant_id = $2
  AND deleted_at IS NULL
RETURNING id, seq_id, tenant_id, id_usuario, nome, codigo, ativo, created_at, updated_at, deleted_at
`

type DesativarOperadorParams struct {
	IDUsuario uuid.UUID `json:"id_usuario"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DesativarOperador(ctx context.Context, arg DesativarOperadorParams) (OperadoresCaixa, error) {
	row := q.db.QueryRow(ctx, desativarOperador, arg.IDUsuario, arg.TenantID)
	var i OperadoresCaixa
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.TenantID,
		&i.IDUsuario,
		&i.Nome,
		&i.Codigo,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOperadorCaixa = `-- name: GetOperadorCaixa :many
SELECT 
    oc.id,
    oc.seq_id,
    oc.tenant_id,
    oc.id_usuario,
    oc.nome,
    oc.codigo,
    oc.ativo,
    oc.created_at,
    oc.updated_at
FROM public.operadores_caixa oc
WHERE oc.id_usuario = $1
  AND oc.deleted_at IS NULL
  AND oc.ativo = 1
`

type GetOperadorCaixaRow struct {
	ID        uuid.UUID   `json:"id"`
	SeqID     int64       `json:"seq_id"`
	TenantID  uuid.UUID   `json:"tenant_id"`
	IDUsuario uuid.UUID   `json:"id_usuario"`
	Nome      string      `json:"nome"`
	Codigo    pgtype.Text `json:"codigo"`
	Ativo     int16       `json:"ativo"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) GetOperadorCaixa(ctx context.Context, idUsuario uuid.UUID) ([]GetOperadorCaixaRow, error) {
	rows, err := q.db.Query(ctx, getOperadorCaixa, idUsuario)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOperadorCaixaRow
	for rows.Next() {
		var i GetOperadorCaixaRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.TenantID,
			&i.IDUsuario,
			&i.Nome,
			&i.Codigo,
			&i.Ativo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperadorCaixaByIdUsuarioAndTenant = `-- name: GetOperadorCaixaByIdUsuarioAndTenant :many
SELECT 
    oc.id,
    oc.seq_id,
    oc.tenant_id,
    oc.id_usuario,
    oc.nome,
    oc.codigo,
    oc.ativo,
    oc.created_at,
    oc.updated_at
FROM public.operadores_caixa oc
WHERE oc.id_usuario = $1
  AND oc.tenant_id = $2
  AND oc.deleted_at IS NULL
  AND oc.ativo = 1
`

type GetOperadorCaixaByIdUsuarioAndTenantParams struct {
	IDUsuario uuid.UUID `json:"id_usuario"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

type GetOperadorCaixaByIdUsuarioAndTenantRow struct {
	ID        uuid.UUID   `json:"id"`
	SeqID     int64       `json:"seq_id"`
	TenantID  uuid.UUID   `json:"tenant_id"`
	IDUsuario uuid.UUID   `json:"id_usuario"`
	Nome      string      `json:"nome"`
	Codigo    pgtype.Text `json:"codigo"`
	Ativo     int16       `json:"ativo"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) GetOperadorCaixaByIdUsuarioAndTenant(ctx context.Context, arg GetOperadorCaixaByIdUsuarioAndTenantParams) ([]GetOperadorCaixaByIdUsuarioAndTenantRow, error) {
	rows, err := q.db.Query(ctx, getOperadorCaixaByIdUsuarioAndTenant, arg.IDUsuario, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOperadorCaixaByIdUsuarioAndTenantRow
	for rows.Next() {
		var i GetOperadorCaixaByIdUsuarioAndTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.TenantID,
			&i.IDUsuario,
			&i.Nome,
			&i.Codigo,
			&i.Ativo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperadorCaixaWithCaixaAtivo = `-- name: GetOperadorCaixaWithCaixaAtivo :many
SELECT 
    oc.id,
    oc.seq_id,
    oc.nome,
    oc.codigo,
    oc.ativo,
    c.id as caixa_id,
    c.data_abertura,
    c.valor_abertura,
    c.status as caixa_status
FROM public.operadores_caixa oc
LEFT JOIN public.caixas c ON c.id_operador = oc.id 
                          AND c.status = 'A' 
                          AND c.deleted_at IS NULL
WHERE oc.id_usuario = $1     -- UUID do usuário
  AND oc.tenant_id = $2      -- UUID do tenant
  AND oc.deleted_at IS NULL
  AND oc.ativo = 1
`

type GetOperadorCaixaWithCaixaAtivoParams struct {
	IDUsuario uuid.UUID `json:"id_usuario"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

type GetOperadorCaixaWithCaixaAtivoRow struct {
	ID            uuid.UUID          `json:"id"`
	SeqID         int64              `json:"seq_id"`
	Nome          string             `json:"nome"`
	Codigo        pgtype.Text        `json:"codigo"`
	Ativo         int16              `json:"ativo"`
	CaixaID       pgtype.UUID        `json:"caixa_id"`
	DataAbertura  pgtype.Timestamptz `json:"data_abertura"`
	ValorAbertura pgtype.Numeric     `json:"valor_abertura"`
	CaixaStatus   NullStatusCaixa    `json:"caixa_status"`
}

func (q *Queries) GetOperadorCaixaWithCaixaAtivo(ctx context.Context, arg GetOperadorCaixaWithCaixaAtivoParams) ([]GetOperadorCaixaWithCaixaAtivoRow, error) {
	rows, err := q.db.Query(ctx, getOperadorCaixaWithCaixaAtivo, arg.IDUsuario, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOperadorCaixaWithCaixaAtivoRow
	for rows.Next() {
		var i GetOperadorCaixaWithCaixaAtivoRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.Nome,
			&i.Codigo,
			&i.Ativo,
			&i.CaixaID,
			&i.DataAbertura,
			&i.ValorAbertura,
			&i.CaixaStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpr = `-- name: GetOpr :one
SELECT 
    oc.id,
    oc.seq_id,
    oc.tenant_id,
    oc.id_usuario,
    oc.nome,
    oc.codigo,
    oc.ativo,
    oc.created_at,
    oc.updated_at
FROM public.operadores_caixa oc
WHERE oc.id_usuario = $1
  AND oc.tenant_id = $2
  AND oc.deleted_at IS NULL LIMIT 1
`

type GetOprParams struct {
	IDUsuario uuid.UUID `json:"id_usuario"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

type GetOprRow struct {
	ID        uuid.UUID   `json:"id"`
	SeqID     int64       `json:"seq_id"`
	TenantID  uuid.UUID   `json:"tenant_id"`
	IDUsuario uuid.UUID   `json:"id_usuario"`
	Nome      string      `json:"nome"`
	Codigo    pgtype.Text `json:"codigo"`
	Ativo     int16       `json:"ativo"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) GetOpr(ctx context.Context, arg GetOprParams) (GetOprRow, error) {
	row := q.db.QueryRow(ctx, getOpr, arg.IDUsuario, arg.TenantID)
	var i GetOprRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.TenantID,
		&i.IDUsuario,
		&i.Nome,
		&i.Codigo,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isOperadorAtivo = `-- name: IsOperadorAtivo :one
SELECT EXISTS (
    SELECT 1 
    FROM public.operadores_caixa 
    WHERE id_usuario = $1        -- UUID do usuário
      AND tenant_id = $2         -- UUID do tenant
      AND deleted_at IS NULL
      AND ativo = 1
) as is_operador
`

type IsOperadorAtivoParams struct {
	IDUsuario uuid.UUID `json:"id_usuario"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

func (q *Queries) IsOperadorAtivo(ctx context.Context, arg IsOperadorAtivoParams) (bool, error) {
	row := q.db.QueryRow(ctx, isOperadorAtivo, arg.IDUsuario, arg.TenantID)
	var is_operador bool
	err := row.Scan(&is_operador)
	return is_operador, err
}

const listarOperadoresAtivos = `-- name: ListarOperadoresAtivos :many
SELECT 
    oc.id,
    oc.nome,
    oc.codigo,
    u.email,
    oc.created_at,
    CASE 
        WHEN c.id IS NOT NULL THEN 'COM_CAIXA_ABERTO'
        ELSE 'DISPONIVEL'
    END as status_caixa
FROM public.operadores_caixa oc
JOIN public.users u ON u.id = oc.id_usuario
LEFT JOIN public.caixas c ON c.id_operador = oc.id 
                          AND c.status = 'A' 
                          AND c.deleted_at IS NULL
WHERE oc.tenant_id = $1
  AND oc.deleted_at IS NULL
  AND oc.ativo = 1
ORDER BY oc.nome
`

type ListarOperadoresAtivosRow struct {
	ID          uuid.UUID   `json:"id"`
	Nome        string      `json:"nome"`
	Codigo      pgtype.Text `json:"codigo"`
	Email       string      `json:"email"`
	CreatedAt   time.Time   `json:"created_at"`
	StatusCaixa string      `json:"status_caixa"`
}

func (q *Queries) ListarOperadoresAtivos(ctx context.Context, tenantID uuid.UUID) ([]ListarOperadoresAtivosRow, error) {
	rows, err := q.db.Query(ctx, listarOperadoresAtivos, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarOperadoresAtivosRow
	for rows.Next() {
		var i ListarOperadoresAtivosRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Codigo,
			&i.Email,
			&i.CreatedAt,
			&i.StatusCaixa,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listarOperadoresComCaixaAberto = `-- name: ListarOperadoresComCaixaAberto :many
SELECT 
    oc.id,
    oc.nome,
    oc.codigo,
    c.id as caixa_id,
    c.data_abertura,
    c.valor_abertura
FROM public.operadores_caixa oc
JOIN public.caixas c ON c.id_operador = oc.id 
                     AND c.status = 'A'
                     AND c.deleted_at IS NULL
WHERE oc.tenant_id = $1
  AND oc.deleted_at IS NULL
  AND oc.ativo = 1
ORDER BY c.data_abertura DESC
`

type ListarOperadoresComCaixaAbertoRow struct {
	ID            uuid.UUID      `json:"id"`
	Nome          string         `json:"nome"`
	Codigo        pgtype.Text    `json:"codigo"`
	CaixaID       uuid.UUID      `json:"caixa_id"`
	DataAbertura  time.Time      `json:"data_abertura"`
	ValorAbertura pgtype.Numeric `json:"valor_abertura"`
}

func (q *Queries) ListarOperadoresComCaixaAberto(ctx context.Context, tenantID uuid.UUID) ([]ListarOperadoresComCaixaAbertoRow, error) {
	rows, err := q.db.Query(ctx, listarOperadoresComCaixaAberto, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarOperadoresComCaixaAbertoRow
	for rows.Next() {
		var i ListarOperadoresComCaixaAbertoRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Codigo,
			&i.CaixaID,
			&i.DataAbertura,
			&i.ValorAbertura,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listarOperadoresDisponiveis = `-- name: ListarOperadoresDisponiveis :many
SELECT 
    oc.id,
    oc.nome,
    oc.codigo,
    u.email
FROM public.operadores_caixa oc
JOIN public.users u ON u.id = oc.id_usuario
WHERE oc.tenant_id = $1
  AND oc.deleted_at IS NULL  
  AND oc.ativo = 1
  AND NOT EXISTS (
      SELECT 1 FROM public.caixas c 
      WHERE c.id_operador = oc.id 
        AND c.status = 'A' 
        AND c.deleted_at IS NULL
  )
ORDER BY oc.nome
`

type ListarOperadoresDisponiveisRow struct {
	ID     uuid.UUID   `json:"id"`
	Nome   string      `json:"nome"`
	Codigo pgtype.Text `json:"codigo"`
	Email  string      `json:"email"`
}

func (q *Queries) ListarOperadoresDisponiveis(ctx context.Context, tenantID uuid.UUID) ([]ListarOperadoresDisponiveisRow, error) {
	rows, err := q.db.Query(ctx, listarOperadoresDisponiveis, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListarOperadoresDisponiveisRow
	for rows.Next() {
		var i ListarOperadoresDisponiveisRow
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Codigo,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reativarOperador = `-- name: ReativarOperador :one
UPDATE public.operadores_caixa
SET deleted_at = NULL,
    ativo = 1,
    updated_at = now()
WHERE id_usuario = $1
  AND tenant_id = $2
RETURNING id, seq_id, tenant_id, id_usuario, nome, codigo, ativo, created_at, updated_at, deleted_at
`

type ReativarOperadorParams struct {
	IDUsuario uuid.UUID `json:"id_usuario"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ReativarOperador(ctx context.Context, arg ReativarOperadorParams) (OperadoresCaixa, error) {
	row := q.db.QueryRow(ctx, reativarOperador, arg.IDUsuario, arg.TenantID)
	var i OperadoresCaixa
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.TenantID,
		&i.IDUsuario,
		&i.Nome,
		&i.Codigo,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const reativarOperadorF = `-- name: ReativarOperadorF :one
SELECT upsert_operador_caixa FROM public.upsert_operador_caixa(
    $1,
    $2,
    $3,
    NULL,  -- sem código
    1      -- reativar
)
`

type ReativarOperadorFParams struct {
	PTenantID  uuid.UUID `json:"p_tenant_id"`
	PIDUsuario uuid.UUID `json:"p_id_usuario"`
	PNome      string    `json:"p_nome"`
}

func (q *Queries) ReativarOperadorF(ctx context.Context, arg ReativarOperadorFParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, reativarOperadorF, arg.PTenantID, arg.PIDUsuario, arg.PNome)
	var upsert_operador_caixa interface{}
	err := row.Scan(&upsert_operador_caixa)
	return upsert_operador_caixa, err
}

const updateOperador = `-- name: UpdateOperador :one
SELECT upsert_operador_caixa FROM public.upsert_operador_caixa(
    $1,
    $2,
    $3,
    NULL,
    1
)
`

type UpdateOperadorParams struct {
	PTenantID  uuid.UUID `json:"p_tenant_id"`
	PIDUsuario uuid.UUID `json:"p_id_usuario"`
	PNome      string    `json:"p_nome"`
}

func (q *Queries) UpdateOperador(ctx context.Context, arg UpdateOperadorParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, updateOperador, arg.PTenantID, arg.PIDUsuario, arg.PNome)
	var upsert_operador_caixa interface{}
	err := row.Scan(&upsert_operador_caixa)
	return upsert_operador_caixa, err
}

const upsertOperadorCaixa = `-- name: UpsertOperadorCaixa :one
INSERT INTO public.operadores_caixa (
    tenant_id,
    id_usuario, 
    nome,
    codigo,
    ativo
) VALUES (
    $1,  -- tenant_id
    $2,  -- id_usuario
    $3,  -- nome
    $4,  -- codigo (pode ser NULL)
    $5   -- ativo (1 ou 0)
)
ON CONFLICT (tenant_id, id_usuario) 
DO UPDATE SET
    nome = EXCLUDED.nome,
    codigo = EXCLUDED.codigo,
    ativo = EXCLUDED.ativo,
    updated_at = now(),
    deleted_at = NULL  -- reativa se estava deletado
WHERE operadores_caixa.deleted_at IS NULL
RETURNING id, seq_id, tenant_id, id_usuario, nome, codigo, ativo, created_at, updated_at, deleted_at
`

type UpsertOperadorCaixaParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	IDUsuario uuid.UUID   `json:"id_usuario"`
	Nome      string      `json:"nome"`
	Codigo    pgtype.Text `json:"codigo"`
	Ativo     int16       `json:"ativo"`
}

// ---------------------------------------------------------------------------
// 2. UPSERT (INSERT ou UPDATE)
// ---------------------------------------------------------------------------
func (q *Queries) UpsertOperadorCaixa(ctx context.Context, arg UpsertOperadorCaixaParams) (OperadoresCaixa, error) {
	row := q.db.QueryRow(ctx, upsertOperadorCaixa,
		arg.TenantID,
		arg.IDUsuario,
		arg.Nome,
		arg.Codigo,
		arg.Ativo,
	)
	var i OperadoresCaixa
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.TenantID,
		&i.IDUsuario,
		&i.Nome,
		&i.Codigo,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const upsertOperadorCaixaCompleto = `-- name: UpsertOperadorCaixaCompleto :one
WITH upsert_operador AS (
    INSERT INTO public.operadores_caixa (
        tenant_id,
        id_usuario,
        nome, 
        codigo,
        ativo
    ) VALUES (
        $1,  -- tenant_id
        $2,  -- id_usuario  
        $3,  -- nome
        $4,  -- codigo
        $5   -- ativo
    )
    ON CONFLICT (tenant_id, id_usuario) 
    DO UPDATE SET
        nome = EXCLUDED.nome,
        codigo = EXCLUDED.codigo, 
        ativo = EXCLUDED.ativo,
        updated_at = now(),
        deleted_at = NULL
    WHERE operadores_caixa.deleted_at IS NULL
    RETURNING id, seq_id, tenant_id, id_usuario, nome, codigo, ativo, created_at, updated_at, deleted_at
)
SELECT 
    id,
    seq_id,
    tenant_id,
    id_usuario,
    nome,
    codigo,
    ativo,
    created_at,
    updated_at
FROM upsert_operador
`

type UpsertOperadorCaixaCompletoParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	IDUsuario uuid.UUID   `json:"id_usuario"`
	Nome      string      `json:"nome"`
	Codigo    pgtype.Text `json:"codigo"`
	Ativo     int16       `json:"ativo"`
}

type UpsertOperadorCaixaCompletoRow struct {
	ID        uuid.UUID   `json:"id"`
	SeqID     int64       `json:"seq_id"`
	TenantID  uuid.UUID   `json:"tenant_id"`
	IDUsuario uuid.UUID   `json:"id_usuario"`
	Nome      string      `json:"nome"`
	Codigo    pgtype.Text `json:"codigo"`
	Ativo     int16       `json:"ativo"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) UpsertOperadorCaixaCompleto(ctx context.Context, arg UpsertOperadorCaixaCompletoParams) (UpsertOperadorCaixaCompletoRow, error) {
	row := q.db.QueryRow(ctx, upsertOperadorCaixaCompleto,
		arg.TenantID,
		arg.IDUsuario,
		arg.Nome,
		arg.Codigo,
		arg.Ativo,
	)
	var i UpsertOperadorCaixaCompletoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.TenantID,
		&i.IDUsuario,
		&i.Nome,
		&i.Codigo,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const verificarCodigoExiste = `-- name: VerificarCodigoExiste :one
SELECT EXISTS (
    SELECT 1 FROM public.operadores_caixa
    WHERE tenant_id = $1
      AND codigo = $2
      AND deleted_at IS NULL
      AND id_usuario != $3  -- excluir o próprio usuário na edição
) as codigo_existe
`

type VerificarCodigoExisteParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	Codigo    pgtype.Text `json:"codigo"`
	IDUsuario uuid.UUID   `json:"id_usuario"`
}

func (q *Queries) VerificarCodigoExiste(ctx context.Context, arg VerificarCodigoExisteParams) (bool, error) {
	row := q.db.QueryRow(ctx, verificarCodigoExiste, arg.TenantID, arg.Codigo, arg.IDUsuario)
	var codigo_existe bool
	err := row.Scan(&codigo_existe)
	return codigo_existe, err
}
