// Code generated by SQLBoiler 4.18.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models_sql_boiler

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Cliente is an object representing the database table.
type Cliente struct {
	ID              string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	TenantID        string      `boil:"tenant_id" json:"tenant_id" toml:"tenant_id" yaml:"tenant_id"`
	TipoPessoa      string      `boil:"tipo_pessoa" json:"tipo_pessoa" toml:"tipo_pessoa" yaml:"tipo_pessoa"`
	NomeRazaoSocial string      `boil:"nome_razao_social" json:"nome_razao_social" toml:"nome_razao_social" yaml:"nome_razao_social"`
	NomeFantasia    null.String `boil:"nome_fantasia" json:"nome_fantasia,omitempty" toml:"nome_fantasia" yaml:"nome_fantasia,omitempty"`
	CPF             null.String `boil:"cpf" json:"cpf,omitempty" toml:"cpf" yaml:"cpf,omitempty"`
	CNPJ            null.String `boil:"cnpj" json:"cnpj,omitempty" toml:"cnpj" yaml:"cnpj,omitempty"`
	RG              null.String `boil:"rg" json:"rg,omitempty" toml:"rg" yaml:"rg,omitempty"`
	Ie              null.String `boil:"ie" json:"ie,omitempty" toml:"ie" yaml:"ie,omitempty"`
	Im              null.String `boil:"im" json:"im,omitempty" toml:"im" yaml:"im,omitempty"`
	DataNascimento  null.Time   `boil:"data_nascimento" json:"data_nascimento,omitempty" toml:"data_nascimento" yaml:"data_nascimento,omitempty"`
	Email           null.String `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	Telefone        null.String `boil:"telefone" json:"telefone,omitempty" toml:"telefone" yaml:"telefone,omitempty"`
	Celular         null.String `boil:"celular" json:"celular,omitempty" toml:"celular" yaml:"celular,omitempty"`
	Cep             null.String `boil:"cep" json:"cep,omitempty" toml:"cep" yaml:"cep,omitempty"`
	Logradouro      null.String `boil:"logradouro" json:"logradouro,omitempty" toml:"logradouro" yaml:"logradouro,omitempty"`
	Numero          null.String `boil:"numero" json:"numero,omitempty" toml:"numero" yaml:"numero,omitempty"`
	Complemento     null.String `boil:"complemento" json:"complemento,omitempty" toml:"complemento" yaml:"complemento,omitempty"`
	Bairro          null.String `boil:"bairro" json:"bairro,omitempty" toml:"bairro" yaml:"bairro,omitempty"`
	Cidade          null.String `boil:"cidade" json:"cidade,omitempty" toml:"cidade" yaml:"cidade,omitempty"`
	Uf              null.String `boil:"uf" json:"uf,omitempty" toml:"uf" yaml:"uf,omitempty"`
	CreatedAt       time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt       time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *clienteR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L clienteL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ClienteColumns = struct {
	ID              string
	TenantID        string
	TipoPessoa      string
	NomeRazaoSocial string
	NomeFantasia    string
	CPF             string
	CNPJ            string
	RG              string
	Ie              string
	Im              string
	DataNascimento  string
	Email           string
	Telefone        string
	Celular         string
	Cep             string
	Logradouro      string
	Numero          string
	Complemento     string
	Bairro          string
	Cidade          string
	Uf              string
	CreatedAt       string
	UpdatedAt       string
}{
	ID:              "id",
	TenantID:        "tenant_id",
	TipoPessoa:      "tipo_pessoa",
	NomeRazaoSocial: "nome_razao_social",
	NomeFantasia:    "nome_fantasia",
	CPF:             "cpf",
	CNPJ:            "cnpj",
	RG:              "rg",
	Ie:              "ie",
	Im:              "im",
	DataNascimento:  "data_nascimento",
	Email:           "email",
	Telefone:        "telefone",
	Celular:         "celular",
	Cep:             "cep",
	Logradouro:      "logradouro",
	Numero:          "numero",
	Complemento:     "complemento",
	Bairro:          "bairro",
	Cidade:          "cidade",
	Uf:              "uf",
	CreatedAt:       "created_at",
	UpdatedAt:       "updated_at",
}

var ClienteTableColumns = struct {
	ID              string
	TenantID        string
	TipoPessoa      string
	NomeRazaoSocial string
	NomeFantasia    string
	CPF             string
	CNPJ            string
	RG              string
	Ie              string
	Im              string
	DataNascimento  string
	Email           string
	Telefone        string
	Celular         string
	Cep             string
	Logradouro      string
	Numero          string
	Complemento     string
	Bairro          string
	Cidade          string
	Uf              string
	CreatedAt       string
	UpdatedAt       string
}{
	ID:              "clientes.id",
	TenantID:        "clientes.tenant_id",
	TipoPessoa:      "clientes.tipo_pessoa",
	NomeRazaoSocial: "clientes.nome_razao_social",
	NomeFantasia:    "clientes.nome_fantasia",
	CPF:             "clientes.cpf",
	CNPJ:            "clientes.cnpj",
	RG:              "clientes.rg",
	Ie:              "clientes.ie",
	Im:              "clientes.im",
	DataNascimento:  "clientes.data_nascimento",
	Email:           "clientes.email",
	Telefone:        "clientes.telefone",
	Celular:         "clientes.celular",
	Cep:             "clientes.cep",
	Logradouro:      "clientes.logradouro",
	Numero:          "clientes.numero",
	Complemento:     "clientes.complemento",
	Bairro:          "clientes.bairro",
	Cidade:          "clientes.cidade",
	Uf:              "clientes.uf",
	CreatedAt:       "clientes.created_at",
	UpdatedAt:       "clientes.updated_at",
}

// Generated where

var ClienteWhere = struct {
	ID              whereHelperstring
	TenantID        whereHelperstring
	TipoPessoa      whereHelperstring
	NomeRazaoSocial whereHelperstring
	NomeFantasia    whereHelpernull_String
	CPF             whereHelpernull_String
	CNPJ            whereHelpernull_String
	RG              whereHelpernull_String
	Ie              whereHelpernull_String
	Im              whereHelpernull_String
	DataNascimento  whereHelpernull_Time
	Email           whereHelpernull_String
	Telefone        whereHelpernull_String
	Celular         whereHelpernull_String
	Cep             whereHelpernull_String
	Logradouro      whereHelpernull_String
	Numero          whereHelpernull_String
	Complemento     whereHelpernull_String
	Bairro          whereHelpernull_String
	Cidade          whereHelpernull_String
	Uf              whereHelpernull_String
	CreatedAt       whereHelpertime_Time
	UpdatedAt       whereHelpertime_Time
}{
	ID:              whereHelperstring{field: "\"clientes\".\"id\""},
	TenantID:        whereHelperstring{field: "\"clientes\".\"tenant_id\""},
	TipoPessoa:      whereHelperstring{field: "\"clientes\".\"tipo_pessoa\""},
	NomeRazaoSocial: whereHelperstring{field: "\"clientes\".\"nome_razao_social\""},
	NomeFantasia:    whereHelpernull_String{field: "\"clientes\".\"nome_fantasia\""},
	CPF:             whereHelpernull_String{field: "\"clientes\".\"cpf\""},
	CNPJ:            whereHelpernull_String{field: "\"clientes\".\"cnpj\""},
	RG:              whereHelpernull_String{field: "\"clientes\".\"rg\""},
	Ie:              whereHelpernull_String{field: "\"clientes\".\"ie\""},
	Im:              whereHelpernull_String{field: "\"clientes\".\"im\""},
	DataNascimento:  whereHelpernull_Time{field: "\"clientes\".\"data_nascimento\""},
	Email:           whereHelpernull_String{field: "\"clientes\".\"email\""},
	Telefone:        whereHelpernull_String{field: "\"clientes\".\"telefone\""},
	Celular:         whereHelpernull_String{field: "\"clientes\".\"celular\""},
	Cep:             whereHelpernull_String{field: "\"clientes\".\"cep\""},
	Logradouro:      whereHelpernull_String{field: "\"clientes\".\"logradouro\""},
	Numero:          whereHelpernull_String{field: "\"clientes\".\"numero\""},
	Complemento:     whereHelpernull_String{field: "\"clientes\".\"complemento\""},
	Bairro:          whereHelpernull_String{field: "\"clientes\".\"bairro\""},
	Cidade:          whereHelpernull_String{field: "\"clientes\".\"cidade\""},
	Uf:              whereHelpernull_String{field: "\"clientes\".\"uf\""},
	CreatedAt:       whereHelpertime_Time{field: "\"clientes\".\"created_at\""},
	UpdatedAt:       whereHelpertime_Time{field: "\"clientes\".\"updated_at\""},
}

// ClienteRels is where relationship names are stored.
var ClienteRels = struct {
	Tenant           string
	IDClientePedidos string
}{
	Tenant:           "Tenant",
	IDClientePedidos: "IDClientePedidos",
}

// clienteR is where relationships are stored.
type clienteR struct {
	Tenant           *Tenant     `boil:"Tenant" json:"Tenant" toml:"Tenant" yaml:"Tenant"`
	IDClientePedidos PedidoSlice `boil:"IDClientePedidos" json:"IDClientePedidos" toml:"IDClientePedidos" yaml:"IDClientePedidos"`
}

// NewStruct creates a new relationship struct
func (*clienteR) NewStruct() *clienteR {
	return &clienteR{}
}

func (r *clienteR) GetTenant() *Tenant {
	if r == nil {
		return nil
	}
	return r.Tenant
}

func (r *clienteR) GetIDClientePedidos() PedidoSlice {
	if r == nil {
		return nil
	}
	return r.IDClientePedidos
}

// clienteL is where Load methods for each relationship are stored.
type clienteL struct{}

var (
	clienteAllColumns            = []string{"id", "tenant_id", "tipo_pessoa", "nome_razao_social", "nome_fantasia", "cpf", "cnpj", "rg", "ie", "im", "data_nascimento", "email", "telefone", "celular", "cep", "logradouro", "numero", "complemento", "bairro", "cidade", "uf", "created_at", "updated_at"}
	clienteColumnsWithoutDefault = []string{"tenant_id", "tipo_pessoa", "nome_razao_social"}
	clienteColumnsWithDefault    = []string{"id", "nome_fantasia", "cpf", "cnpj", "rg", "ie", "im", "data_nascimento", "email", "telefone", "celular", "cep", "logradouro", "numero", "complemento", "bairro", "cidade", "uf", "created_at", "updated_at"}
	clientePrimaryKeyColumns     = []string{"id"}
	clienteGeneratedColumns      = []string{}
)

type (
	// ClienteSlice is an alias for a slice of pointers to Cliente.
	// This should almost always be used instead of []Cliente.
	ClienteSlice []*Cliente
	// ClienteHook is the signature for custom Cliente hook methods
	ClienteHook func(context.Context, boil.ContextExecutor, *Cliente) error

	clienteQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	clienteType                 = reflect.TypeOf(&Cliente{})
	clienteMapping              = queries.MakeStructMapping(clienteType)
	clientePrimaryKeyMapping, _ = queries.BindMapping(clienteType, clienteMapping, clientePrimaryKeyColumns)
	clienteInsertCacheMut       sync.RWMutex
	clienteInsertCache          = make(map[string]insertCache)
	clienteUpdateCacheMut       sync.RWMutex
	clienteUpdateCache          = make(map[string]updateCache)
	clienteUpsertCacheMut       sync.RWMutex
	clienteUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var clienteAfterSelectMu sync.Mutex
var clienteAfterSelectHooks []ClienteHook

var clienteBeforeInsertMu sync.Mutex
var clienteBeforeInsertHooks []ClienteHook
var clienteAfterInsertMu sync.Mutex
var clienteAfterInsertHooks []ClienteHook

var clienteBeforeUpdateMu sync.Mutex
var clienteBeforeUpdateHooks []ClienteHook
var clienteAfterUpdateMu sync.Mutex
var clienteAfterUpdateHooks []ClienteHook

var clienteBeforeDeleteMu sync.Mutex
var clienteBeforeDeleteHooks []ClienteHook
var clienteAfterDeleteMu sync.Mutex
var clienteAfterDeleteHooks []ClienteHook

var clienteBeforeUpsertMu sync.Mutex
var clienteBeforeUpsertHooks []ClienteHook
var clienteAfterUpsertMu sync.Mutex
var clienteAfterUpsertHooks []ClienteHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Cliente) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Cliente) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Cliente) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Cliente) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Cliente) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Cliente) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Cliente) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Cliente) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Cliente) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range clienteAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddClienteHook registers your hook function for all future operations.
func AddClienteHook(hookPoint boil.HookPoint, clienteHook ClienteHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		clienteAfterSelectMu.Lock()
		clienteAfterSelectHooks = append(clienteAfterSelectHooks, clienteHook)
		clienteAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		clienteBeforeInsertMu.Lock()
		clienteBeforeInsertHooks = append(clienteBeforeInsertHooks, clienteHook)
		clienteBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		clienteAfterInsertMu.Lock()
		clienteAfterInsertHooks = append(clienteAfterInsertHooks, clienteHook)
		clienteAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		clienteBeforeUpdateMu.Lock()
		clienteBeforeUpdateHooks = append(clienteBeforeUpdateHooks, clienteHook)
		clienteBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		clienteAfterUpdateMu.Lock()
		clienteAfterUpdateHooks = append(clienteAfterUpdateHooks, clienteHook)
		clienteAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		clienteBeforeDeleteMu.Lock()
		clienteBeforeDeleteHooks = append(clienteBeforeDeleteHooks, clienteHook)
		clienteBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		clienteAfterDeleteMu.Lock()
		clienteAfterDeleteHooks = append(clienteAfterDeleteHooks, clienteHook)
		clienteAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		clienteBeforeUpsertMu.Lock()
		clienteBeforeUpsertHooks = append(clienteBeforeUpsertHooks, clienteHook)
		clienteBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		clienteAfterUpsertMu.Lock()
		clienteAfterUpsertHooks = append(clienteAfterUpsertHooks, clienteHook)
		clienteAfterUpsertMu.Unlock()
	}
}

// One returns a single cliente record from the query.
func (q clienteQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Cliente, error) {
	o := &Cliente{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models_sql_boiler: failed to execute a one query for clientes")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Cliente records from the query.
func (q clienteQuery) All(ctx context.Context, exec boil.ContextExecutor) (ClienteSlice, error) {
	var o []*Cliente

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models_sql_boiler: failed to assign all query results to Cliente slice")
	}

	if len(clienteAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Cliente records in the query.
func (q clienteQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to count clientes rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q clienteQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models_sql_boiler: failed to check if clientes exists")
	}

	return count > 0, nil
}

// Tenant pointed to by the foreign key.
func (o *Cliente) Tenant(mods ...qm.QueryMod) tenantQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TenantID),
	}

	queryMods = append(queryMods, mods...)

	return Tenants(queryMods...)
}

// IDClientePedidos retrieves all the pedido's Pedidos with an executor via id_cliente column.
func (o *Cliente) IDClientePedidos(mods ...qm.QueryMod) pedidoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"pedidos\".\"id_cliente\"=?", o.ID),
	)

	return Pedidos(queryMods...)
}

// LoadTenant allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (clienteL) LoadTenant(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCliente interface{}, mods queries.Applicator) error {
	var slice []*Cliente
	var object *Cliente

	if singular {
		var ok bool
		object, ok = maybeCliente.(*Cliente)
		if !ok {
			object = new(Cliente)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCliente)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCliente))
			}
		}
	} else {
		s, ok := maybeCliente.(*[]*Cliente)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCliente)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCliente))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &clienteR{}
		}
		args[object.TenantID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &clienteR{}
			}

			args[obj.TenantID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`tenants`),
		qm.WhereIn(`tenants.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Tenant")
	}

	var resultSlice []*Tenant
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Tenant")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for tenants")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tenants")
	}

	if len(tenantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Tenant = foreign
		if foreign.R == nil {
			foreign.R = &tenantR{}
		}
		foreign.R.Clientes = append(foreign.R.Clientes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TenantID == foreign.ID {
				local.R.Tenant = foreign
				if foreign.R == nil {
					foreign.R = &tenantR{}
				}
				foreign.R.Clientes = append(foreign.R.Clientes, local)
				break
			}
		}
	}

	return nil
}

// LoadIDClientePedidos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (clienteL) LoadIDClientePedidos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCliente interface{}, mods queries.Applicator) error {
	var slice []*Cliente
	var object *Cliente

	if singular {
		var ok bool
		object, ok = maybeCliente.(*Cliente)
		if !ok {
			object = new(Cliente)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCliente)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCliente))
			}
		}
	} else {
		s, ok := maybeCliente.(*[]*Cliente)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCliente)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCliente))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &clienteR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &clienteR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`pedidos`),
		qm.WhereIn(`pedidos.id_cliente in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load pedidos")
	}

	var resultSlice []*Pedido
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice pedidos")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on pedidos")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for pedidos")
	}

	if len(pedidoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.IDClientePedidos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pedidoR{}
			}
			foreign.R.IDClienteCliente = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.IDCliente {
				local.R.IDClientePedidos = append(local.R.IDClientePedidos, foreign)
				if foreign.R == nil {
					foreign.R = &pedidoR{}
				}
				foreign.R.IDClienteCliente = local
				break
			}
		}
	}

	return nil
}

// SetTenant of the cliente to the related item.
// Sets o.R.Tenant to related.
// Adds o to related.R.Clientes.
func (o *Cliente) SetTenant(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Tenant) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"clientes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"tenant_id"}),
		strmangle.WhereClause("\"", "\"", 2, clientePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TenantID = related.ID
	if o.R == nil {
		o.R = &clienteR{
			Tenant: related,
		}
	} else {
		o.R.Tenant = related
	}

	if related.R == nil {
		related.R = &tenantR{
			Clientes: ClienteSlice{o},
		}
	} else {
		related.R.Clientes = append(related.R.Clientes, o)
	}

	return nil
}

// AddIDClientePedidos adds the given related objects to the existing relationships
// of the cliente, optionally inserting them as new records.
// Appends related to o.R.IDClientePedidos.
// Sets related.R.IDClienteCliente appropriately.
func (o *Cliente) AddIDClientePedidos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Pedido) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.IDCliente = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"pedidos\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"id_cliente"}),
				strmangle.WhereClause("\"", "\"", 2, pedidoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.IDCliente = o.ID
		}
	}

	if o.R == nil {
		o.R = &clienteR{
			IDClientePedidos: related,
		}
	} else {
		o.R.IDClientePedidos = append(o.R.IDClientePedidos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pedidoR{
				IDClienteCliente: o,
			}
		} else {
			rel.R.IDClienteCliente = o
		}
	}
	return nil
}

// Clientes retrieves all the records using an executor.
func Clientes(mods ...qm.QueryMod) clienteQuery {
	mods = append(mods, qm.From("\"clientes\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"clientes\".*"})
	}

	return clienteQuery{q}
}

// FindCliente retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCliente(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Cliente, error) {
	clienteObj := &Cliente{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"clientes\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, clienteObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models_sql_boiler: unable to select from clientes")
	}

	if err = clienteObj.doAfterSelectHooks(ctx, exec); err != nil {
		return clienteObj, err
	}

	return clienteObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Cliente) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models_sql_boiler: no clientes provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clienteColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	clienteInsertCacheMut.RLock()
	cache, cached := clienteInsertCache[key]
	clienteInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			clienteAllColumns,
			clienteColumnsWithDefault,
			clienteColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(clienteType, clienteMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(clienteType, clienteMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"clientes\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"clientes\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to insert into clientes")
	}

	if !cached {
		clienteInsertCacheMut.Lock()
		clienteInsertCache[key] = cache
		clienteInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Cliente.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Cliente) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	clienteUpdateCacheMut.RLock()
	cache, cached := clienteUpdateCache[key]
	clienteUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			clienteAllColumns,
			clientePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models_sql_boiler: unable to update clientes, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"clientes\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, clientePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(clienteType, clienteMapping, append(wl, clientePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to update clientes row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to get rows affected by update for clientes")
	}

	if !cached {
		clienteUpdateCacheMut.Lock()
		clienteUpdateCache[key] = cache
		clienteUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q clienteQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to update all for clientes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to retrieve rows affected for clientes")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ClienteSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models_sql_boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"clientes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, clientePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to update all in cliente slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to retrieve rows affected all in update all cliente")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Cliente) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models_sql_boiler: no clientes provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(clienteColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	clienteUpsertCacheMut.RLock()
	cache, cached := clienteUpsertCache[key]
	clienteUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			clienteAllColumns,
			clienteColumnsWithDefault,
			clienteColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			clienteAllColumns,
			clientePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models_sql_boiler: unable to upsert clientes, could not build update column list")
		}

		ret := strmangle.SetComplement(clienteAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(clientePrimaryKeyColumns) == 0 {
				return errors.New("models_sql_boiler: unable to upsert clientes, could not build conflict column list")
			}

			conflict = make([]string, len(clientePrimaryKeyColumns))
			copy(conflict, clientePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"clientes\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(clienteType, clienteMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(clienteType, clienteMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to upsert clientes")
	}

	if !cached {
		clienteUpsertCacheMut.Lock()
		clienteUpsertCache[key] = cache
		clienteUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Cliente record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Cliente) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models_sql_boiler: no Cliente provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), clientePrimaryKeyMapping)
	sql := "DELETE FROM \"clientes\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to delete from clientes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to get rows affected by delete for clientes")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q clienteQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models_sql_boiler: no clienteQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to delete all from clientes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to get rows affected by deleteall for clientes")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ClienteSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(clienteBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"clientes\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, clientePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: unable to delete all from cliente slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to get rows affected by deleteall for clientes")
	}

	if len(clienteAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Cliente) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCliente(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ClienteSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ClienteSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), clientePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"clientes\".* FROM \"clientes\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, clientePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to reload all in ClienteSlice")
	}

	*o = slice

	return nil
}

// ClienteExists checks if the Cliente row exists.
func ClienteExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"clientes\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models_sql_boiler: unable to check if clientes exists")
	}

	return exists, nil
}

// Exists checks if the Cliente row exists.
func (o *Cliente) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ClienteExists(ctx, exec, o.ID)
}
