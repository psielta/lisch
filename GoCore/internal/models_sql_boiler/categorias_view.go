// Code generated by SQLBoiler 4.18.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models_sql_boiler

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// CategoriasView is an object representing the database table.
type CategoriasView struct {
	ID                null.String `boil:"id" json:"id,omitempty" toml:"id" yaml:"id,omitempty"`
	SeqID             null.Int64  `boil:"seq_id" json:"seq_id,omitempty" toml:"seq_id" yaml:"seq_id,omitempty"`
	IDTenant          null.String `boil:"id_tenant" json:"id_tenant,omitempty" toml:"id_tenant" yaml:"id_tenant,omitempty"`
	IDCulinaria       null.Int    `boil:"id_culinaria" json:"id_culinaria,omitempty" toml:"id_culinaria" yaml:"id_culinaria,omitempty"`
	Nome              null.String `boil:"nome" json:"nome,omitempty" toml:"nome" yaml:"nome,omitempty"`
	Descricao         null.String `boil:"descricao" json:"descricao,omitempty" toml:"descricao" yaml:"descricao,omitempty"`
	Inicio            null.Time   `boil:"inicio" json:"inicio,omitempty" toml:"inicio" yaml:"inicio,omitempty"`
	Fim               null.Time   `boil:"fim" json:"fim,omitempty" toml:"fim" yaml:"fim,omitempty"`
	Ativo             null.Int16  `boil:"ativo" json:"ativo,omitempty" toml:"ativo" yaml:"ativo,omitempty"`
	OpcaoMeia         null.String `boil:"opcao_meia" json:"opcao_meia,omitempty" toml:"opcao_meia" yaml:"opcao_meia,omitempty"`
	Ordem             null.Int    `boil:"ordem" json:"ordem,omitempty" toml:"ordem" yaml:"ordem,omitempty"`
	DisponivelDomingo null.Int16  `boil:"disponivel_domingo" json:"disponivel_domingo,omitempty" toml:"disponivel_domingo" yaml:"disponivel_domingo,omitempty"`
	DisponivelSegunda null.Int16  `boil:"disponivel_segunda" json:"disponivel_segunda,omitempty" toml:"disponivel_segunda" yaml:"disponivel_segunda,omitempty"`
	DisponivelTerca   null.Int16  `boil:"disponivel_terca" json:"disponivel_terca,omitempty" toml:"disponivel_terca" yaml:"disponivel_terca,omitempty"`
	DisponivelQuarta  null.Int16  `boil:"disponivel_quarta" json:"disponivel_quarta,omitempty" toml:"disponivel_quarta" yaml:"disponivel_quarta,omitempty"`
	DisponivelQuinta  null.Int16  `boil:"disponivel_quinta" json:"disponivel_quinta,omitempty" toml:"disponivel_quinta" yaml:"disponivel_quinta,omitempty"`
	DisponivelSexta   null.Int16  `boil:"disponivel_sexta" json:"disponivel_sexta,omitempty" toml:"disponivel_sexta" yaml:"disponivel_sexta,omitempty"`
	DisponivelSabado  null.Int16  `boil:"disponivel_sabado" json:"disponivel_sabado,omitempty" toml:"disponivel_sabado" yaml:"disponivel_sabado,omitempty"`
	CreatedAt         null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt         null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt         null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
}

var CategoriasViewColumns = struct {
	ID                string
	SeqID             string
	IDTenant          string
	IDCulinaria       string
	Nome              string
	Descricao         string
	Inicio            string
	Fim               string
	Ativo             string
	OpcaoMeia         string
	Ordem             string
	DisponivelDomingo string
	DisponivelSegunda string
	DisponivelTerca   string
	DisponivelQuarta  string
	DisponivelQuinta  string
	DisponivelSexta   string
	DisponivelSabado  string
	CreatedAt         string
	UpdatedAt         string
	DeletedAt         string
}{
	ID:                "id",
	SeqID:             "seq_id",
	IDTenant:          "id_tenant",
	IDCulinaria:       "id_culinaria",
	Nome:              "nome",
	Descricao:         "descricao",
	Inicio:            "inicio",
	Fim:               "fim",
	Ativo:             "ativo",
	OpcaoMeia:         "opcao_meia",
	Ordem:             "ordem",
	DisponivelDomingo: "disponivel_domingo",
	DisponivelSegunda: "disponivel_segunda",
	DisponivelTerca:   "disponivel_terca",
	DisponivelQuarta:  "disponivel_quarta",
	DisponivelQuinta:  "disponivel_quinta",
	DisponivelSexta:   "disponivel_sexta",
	DisponivelSabado:  "disponivel_sabado",
	CreatedAt:         "created_at",
	UpdatedAt:         "updated_at",
	DeletedAt:         "deleted_at",
}

var CategoriasViewTableColumns = struct {
	ID                string
	SeqID             string
	IDTenant          string
	IDCulinaria       string
	Nome              string
	Descricao         string
	Inicio            string
	Fim               string
	Ativo             string
	OpcaoMeia         string
	Ordem             string
	DisponivelDomingo string
	DisponivelSegunda string
	DisponivelTerca   string
	DisponivelQuarta  string
	DisponivelQuinta  string
	DisponivelSexta   string
	DisponivelSabado  string
	CreatedAt         string
	UpdatedAt         string
	DeletedAt         string
}{
	ID:                "categorias_view.id",
	SeqID:             "categorias_view.seq_id",
	IDTenant:          "categorias_view.id_tenant",
	IDCulinaria:       "categorias_view.id_culinaria",
	Nome:              "categorias_view.nome",
	Descricao:         "categorias_view.descricao",
	Inicio:            "categorias_view.inicio",
	Fim:               "categorias_view.fim",
	Ativo:             "categorias_view.ativo",
	OpcaoMeia:         "categorias_view.opcao_meia",
	Ordem:             "categorias_view.ordem",
	DisponivelDomingo: "categorias_view.disponivel_domingo",
	DisponivelSegunda: "categorias_view.disponivel_segunda",
	DisponivelTerca:   "categorias_view.disponivel_terca",
	DisponivelQuarta:  "categorias_view.disponivel_quarta",
	DisponivelQuinta:  "categorias_view.disponivel_quinta",
	DisponivelSexta:   "categorias_view.disponivel_sexta",
	DisponivelSabado:  "categorias_view.disponivel_sabado",
	CreatedAt:         "categorias_view.created_at",
	UpdatedAt:         "categorias_view.updated_at",
	DeletedAt:         "categorias_view.deleted_at",
}

// Generated where

var CategoriasViewWhere = struct {
	ID                whereHelpernull_String
	SeqID             whereHelpernull_Int64
	IDTenant          whereHelpernull_String
	IDCulinaria       whereHelpernull_Int
	Nome              whereHelpernull_String
	Descricao         whereHelpernull_String
	Inicio            whereHelpernull_Time
	Fim               whereHelpernull_Time
	Ativo             whereHelpernull_Int16
	OpcaoMeia         whereHelpernull_String
	Ordem             whereHelpernull_Int
	DisponivelDomingo whereHelpernull_Int16
	DisponivelSegunda whereHelpernull_Int16
	DisponivelTerca   whereHelpernull_Int16
	DisponivelQuarta  whereHelpernull_Int16
	DisponivelQuinta  whereHelpernull_Int16
	DisponivelSexta   whereHelpernull_Int16
	DisponivelSabado  whereHelpernull_Int16
	CreatedAt         whereHelpernull_Time
	UpdatedAt         whereHelpernull_Time
	DeletedAt         whereHelpernull_Time
}{
	ID:                whereHelpernull_String{field: "\"categorias_view\".\"id\""},
	SeqID:             whereHelpernull_Int64{field: "\"categorias_view\".\"seq_id\""},
	IDTenant:          whereHelpernull_String{field: "\"categorias_view\".\"id_tenant\""},
	IDCulinaria:       whereHelpernull_Int{field: "\"categorias_view\".\"id_culinaria\""},
	Nome:              whereHelpernull_String{field: "\"categorias_view\".\"nome\""},
	Descricao:         whereHelpernull_String{field: "\"categorias_view\".\"descricao\""},
	Inicio:            whereHelpernull_Time{field: "\"categorias_view\".\"inicio\""},
	Fim:               whereHelpernull_Time{field: "\"categorias_view\".\"fim\""},
	Ativo:             whereHelpernull_Int16{field: "\"categorias_view\".\"ativo\""},
	OpcaoMeia:         whereHelpernull_String{field: "\"categorias_view\".\"opcao_meia\""},
	Ordem:             whereHelpernull_Int{field: "\"categorias_view\".\"ordem\""},
	DisponivelDomingo: whereHelpernull_Int16{field: "\"categorias_view\".\"disponivel_domingo\""},
	DisponivelSegunda: whereHelpernull_Int16{field: "\"categorias_view\".\"disponivel_segunda\""},
	DisponivelTerca:   whereHelpernull_Int16{field: "\"categorias_view\".\"disponivel_terca\""},
	DisponivelQuarta:  whereHelpernull_Int16{field: "\"categorias_view\".\"disponivel_quarta\""},
	DisponivelQuinta:  whereHelpernull_Int16{field: "\"categorias_view\".\"disponivel_quinta\""},
	DisponivelSexta:   whereHelpernull_Int16{field: "\"categorias_view\".\"disponivel_sexta\""},
	DisponivelSabado:  whereHelpernull_Int16{field: "\"categorias_view\".\"disponivel_sabado\""},
	CreatedAt:         whereHelpernull_Time{field: "\"categorias_view\".\"created_at\""},
	UpdatedAt:         whereHelpernull_Time{field: "\"categorias_view\".\"updated_at\""},
	DeletedAt:         whereHelpernull_Time{field: "\"categorias_view\".\"deleted_at\""},
}

var (
	categoriasViewAllColumns            = []string{"id", "seq_id", "id_tenant", "id_culinaria", "nome", "descricao", "inicio", "fim", "ativo", "opcao_meia", "ordem", "disponivel_domingo", "disponivel_segunda", "disponivel_terca", "disponivel_quarta", "disponivel_quinta", "disponivel_sexta", "disponivel_sabado", "created_at", "updated_at", "deleted_at"}
	categoriasViewColumnsWithoutDefault = []string{}
	categoriasViewColumnsWithDefault    = []string{"id", "seq_id", "id_tenant", "id_culinaria", "nome", "descricao", "inicio", "fim", "ativo", "opcao_meia", "ordem", "disponivel_domingo", "disponivel_segunda", "disponivel_terca", "disponivel_quarta", "disponivel_quinta", "disponivel_sexta", "disponivel_sabado", "created_at", "updated_at", "deleted_at"}
	categoriasViewPrimaryKeyColumns     = []string{}
	categoriasViewGeneratedColumns      = []string{}
)

type (
	// CategoriasViewSlice is an alias for a slice of pointers to CategoriasView.
	// This should almost always be used instead of []CategoriasView.
	CategoriasViewSlice []*CategoriasView
	// CategoriasViewHook is the signature for custom CategoriasView hook methods
	CategoriasViewHook func(context.Context, boil.ContextExecutor, *CategoriasView) error

	categoriasViewQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	categoriasViewType           = reflect.TypeOf(&CategoriasView{})
	categoriasViewMapping        = queries.MakeStructMapping(categoriasViewType)
	categoriasViewInsertCacheMut sync.RWMutex
	categoriasViewInsertCache    = make(map[string]insertCache)
	categoriasViewUpdateCacheMut sync.RWMutex
	categoriasViewUpdateCache    = make(map[string]updateCache)
	categoriasViewUpsertCacheMut sync.RWMutex
	categoriasViewUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var categoriasViewAfterSelectMu sync.Mutex
var categoriasViewAfterSelectHooks []CategoriasViewHook

var categoriasViewBeforeInsertMu sync.Mutex
var categoriasViewBeforeInsertHooks []CategoriasViewHook
var categoriasViewAfterInsertMu sync.Mutex
var categoriasViewAfterInsertHooks []CategoriasViewHook

var categoriasViewBeforeUpsertMu sync.Mutex
var categoriasViewBeforeUpsertHooks []CategoriasViewHook
var categoriasViewAfterUpsertMu sync.Mutex
var categoriasViewAfterUpsertHooks []CategoriasViewHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CategoriasView) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range categoriasViewAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CategoriasView) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range categoriasViewBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CategoriasView) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range categoriasViewAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CategoriasView) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range categoriasViewBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CategoriasView) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range categoriasViewAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCategoriasViewHook registers your hook function for all future operations.
func AddCategoriasViewHook(hookPoint boil.HookPoint, categoriasViewHook CategoriasViewHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		categoriasViewAfterSelectMu.Lock()
		categoriasViewAfterSelectHooks = append(categoriasViewAfterSelectHooks, categoriasViewHook)
		categoriasViewAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		categoriasViewBeforeInsertMu.Lock()
		categoriasViewBeforeInsertHooks = append(categoriasViewBeforeInsertHooks, categoriasViewHook)
		categoriasViewBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		categoriasViewAfterInsertMu.Lock()
		categoriasViewAfterInsertHooks = append(categoriasViewAfterInsertHooks, categoriasViewHook)
		categoriasViewAfterInsertMu.Unlock()
	case boil.BeforeUpsertHook:
		categoriasViewBeforeUpsertMu.Lock()
		categoriasViewBeforeUpsertHooks = append(categoriasViewBeforeUpsertHooks, categoriasViewHook)
		categoriasViewBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		categoriasViewAfterUpsertMu.Lock()
		categoriasViewAfterUpsertHooks = append(categoriasViewAfterUpsertHooks, categoriasViewHook)
		categoriasViewAfterUpsertMu.Unlock()
	}
}

// One returns a single categoriasView record from the query.
func (q categoriasViewQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CategoriasView, error) {
	o := &CategoriasView{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models_sql_boiler: failed to execute a one query for categorias_view")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CategoriasView records from the query.
func (q categoriasViewQuery) All(ctx context.Context, exec boil.ContextExecutor) (CategoriasViewSlice, error) {
	var o []*CategoriasView

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models_sql_boiler: failed to assign all query results to CategoriasView slice")
	}

	if len(categoriasViewAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CategoriasView records in the query.
func (q categoriasViewQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to count categorias_view rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q categoriasViewQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models_sql_boiler: failed to check if categorias_view exists")
	}

	return count > 0, nil
}

// CategoriasViews retrieves all the records using an executor.
func CategoriasViews(mods ...qm.QueryMod) categoriasViewQuery {
	mods = append(mods, qm.From("\"categorias_view\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"categorias_view\".*"})
	}

	return categoriasViewQuery{q}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CategoriasView) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models_sql_boiler: no categorias_view provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(categoriasViewColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	categoriasViewInsertCacheMut.RLock()
	cache, cached := categoriasViewInsertCache[key]
	categoriasViewInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			categoriasViewAllColumns,
			categoriasViewColumnsWithDefault,
			categoriasViewColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(categoriasViewType, categoriasViewMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(categoriasViewType, categoriasViewMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"categorias_view\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"categorias_view\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to insert into categorias_view")
	}

	if !cached {
		categoriasViewInsertCacheMut.Lock()
		categoriasViewInsertCache[key] = cache
		categoriasViewInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CategoriasView) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models_sql_boiler: no categorias_view provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(categoriasViewColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	categoriasViewUpsertCacheMut.RLock()
	cache, cached := categoriasViewUpsertCache[key]
	categoriasViewUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			categoriasViewAllColumns,
			categoriasViewColumnsWithDefault,
			categoriasViewColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			categoriasViewAllColumns,
			categoriasViewPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models_sql_boiler: unable to upsert categorias_view, could not build update column list")
		}

		ret := strmangle.SetComplement(categoriasViewAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(categoriasViewPrimaryKeyColumns) == 0 {
				return errors.New("models_sql_boiler: unable to upsert categorias_view, could not build conflict column list")
			}

			conflict = make([]string, len(categoriasViewPrimaryKeyColumns))
			copy(conflict, categoriasViewPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"categorias_view\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(categoriasViewType, categoriasViewMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(categoriasViewType, categoriasViewMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to upsert categorias_view")
	}

	if !cached {
		categoriasViewUpsertCacheMut.Lock()
		categoriasViewUpsertCache[key] = cache
		categoriasViewUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
