// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: outbox.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOutboxEvent = `-- name: CreateOutboxEvent :one

INSERT INTO outbox_event (
    tenant_id,
    user_id,
    aggregate_type,
    aggregate_id,
    event_type,
    payload         -- jsonb
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, tenant_id, user_id, aggregate_type, aggregate_id, event_type, payload,
          created_at, processed, attempts, last_error
`

type CreateOutboxEventParams struct {
	TenantID      uuid.UUID `json:"tenant_id"`
	UserID        uuid.UUID `json:"user_id"`
	AggregateType string    `json:"aggregate_type"`
	AggregateID   string    `json:"aggregate_id"`
	EventType     string    `json:"event_type"`
	Payload       []byte    `json:"payload"`
}

type CreateOutboxEventRow struct {
	ID            int64       `json:"id"`
	TenantID      uuid.UUID   `json:"tenant_id"`
	UserID        uuid.UUID   `json:"user_id"`
	AggregateType string      `json:"aggregate_type"`
	AggregateID   string      `json:"aggregate_id"`
	EventType     string      `json:"event_type"`
	Payload       []byte      `json:"payload"`
	CreatedAt     time.Time   `json:"created_at"`
	Processed     bool        `json:"processed"`
	Attempts      int32       `json:"attempts"`
	LastError     pgtype.Text `json:"last_error"`
}

// SQLC Queries para Outbox Event
// ******************************
func (q *Queries) CreateOutboxEvent(ctx context.Context, arg CreateOutboxEventParams) (CreateOutboxEventRow, error) {
	row := q.db.QueryRow(ctx, createOutboxEvent,
		arg.TenantID,
		arg.UserID,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
	)
	var i CreateOutboxEventRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.CreatedAt,
		&i.Processed,
		&i.Attempts,
		&i.LastError,
	)
	return i, err
}

const deleteProcessedOutboxEventsOlderThan = `-- name: DeleteProcessedOutboxEventsOlderThan :exec
/* Limpeza: remova eventos já processados e antigos.
   Ex.: call passando NOW() - interval '30 days'.        */
DELETE FROM outbox_event
WHERE processed = true
  AND created_at < $1
`

func (q *Queries) DeleteProcessedOutboxEventsOlderThan(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.Exec(ctx, deleteProcessedOutboxEventsOlderThan, createdAt)
	return err
}

const getOutboxEvent = `-- name: GetOutboxEvent :one
SELECT
    id, tenant_id, user_id, aggregate_type, aggregate_id, event_type, payload,
    created_at, processed, attempts, last_error
FROM outbox_event
WHERE id = $1
`

type GetOutboxEventRow struct {
	ID            int64       `json:"id"`
	TenantID      uuid.UUID   `json:"tenant_id"`
	UserID        uuid.UUID   `json:"user_id"`
	AggregateType string      `json:"aggregate_type"`
	AggregateID   string      `json:"aggregate_id"`
	EventType     string      `json:"event_type"`
	Payload       []byte      `json:"payload"`
	CreatedAt     time.Time   `json:"created_at"`
	Processed     bool        `json:"processed"`
	Attempts      int32       `json:"attempts"`
	LastError     pgtype.Text `json:"last_error"`
}

func (q *Queries) GetOutboxEvent(ctx context.Context, id int64) (GetOutboxEventRow, error) {
	row := q.db.QueryRow(ctx, getOutboxEvent, id)
	var i GetOutboxEventRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.CreatedAt,
		&i.Processed,
		&i.Attempts,
		&i.LastError,
	)
	return i, err
}

const listUnprocessedOutboxEventsForProcessing = `-- name: ListUnprocessedOutboxEventsForProcessing :many
/*
Seleciona em lote, preservando ordem de commit, bloqueando
as linhas para evitar processamento em paralelo. Use LIMIT
para controlar o tamanho do lote (ex.: 100).            */
WITH to_send AS (
    SELECT id, tenant_id, user_id, aggregate_type, aggregate_id, event_type, payload
    FROM   outbox_event
    WHERE  processed = false
    ORDER  BY created_at
    LIMIT  $1
    FOR UPDATE SKIP LOCKED
)
SELECT id, tenant_id, user_id, aggregate_type, aggregate_id, event_type, payload
FROM   to_send
`

type ListUnprocessedOutboxEventsForProcessingRow struct {
	ID            int64     `json:"id"`
	TenantID      uuid.UUID `json:"tenant_id"`
	UserID        uuid.UUID `json:"user_id"`
	AggregateType string    `json:"aggregate_type"`
	AggregateID   string    `json:"aggregate_id"`
	EventType     string    `json:"event_type"`
	Payload       []byte    `json:"payload"`
}

func (q *Queries) ListUnprocessedOutboxEventsForProcessing(ctx context.Context, limit int32) ([]ListUnprocessedOutboxEventsForProcessingRow, error) {
	rows, err := q.db.Query(ctx, listUnprocessedOutboxEventsForProcessing, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnprocessedOutboxEventsForProcessingRow
	for rows.Next() {
		var i ListUnprocessedOutboxEventsForProcessingRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOutboxEventError = `-- name: MarkOutboxEventError :exec
/*
Grava o motivo da falha e incrementa o número de tentativas.
O serviço de publisher decide se reprocessa ou envia para
DLQ depois de N tentativas.                               */
UPDATE outbox_event
SET    attempts   = attempts + 1,
       last_error = $2          -- texto do erro
WHERE  id = $1
`

type MarkOutboxEventErrorParams struct {
	ID        int64       `json:"id"`
	LastError pgtype.Text `json:"last_error"`
}

func (q *Queries) MarkOutboxEventError(ctx context.Context, arg MarkOutboxEventErrorParams) error {
	_, err := q.db.Exec(ctx, markOutboxEventError, arg.ID, arg.LastError)
	return err
}

const markOutboxEventProcessed = `-- name: MarkOutboxEventProcessed :exec
UPDATE outbox_event
SET    processed = true,
       attempts  = attempts + 1,
       last_error = NULL
WHERE  id = $1
`

func (q *Queries) MarkOutboxEventProcessed(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markOutboxEventProcessed, id)
	return err
}
