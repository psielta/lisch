// Code generated by SQLBoiler 4.18.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models_sql_boiler

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// PedidosView is an object representing the database table.
type PedidosView struct {
	ID                 null.String       `boil:"id" json:"id,omitempty" toml:"id" yaml:"id,omitempty"`
	SeqID              null.Int64        `boil:"seq_id" json:"seq_id,omitempty" toml:"seq_id" yaml:"seq_id,omitempty"`
	TenantID           null.String       `boil:"tenant_id" json:"tenant_id,omitempty" toml:"tenant_id" yaml:"tenant_id,omitempty"`
	IDCliente          null.String       `boil:"id_cliente" json:"id_cliente,omitempty" toml:"id_cliente" yaml:"id_cliente,omitempty"`
	CodigoPedido       null.String       `boil:"codigo_pedido" json:"codigo_pedido,omitempty" toml:"codigo_pedido" yaml:"codigo_pedido,omitempty"`
	DataPedido         null.Time         `boil:"data_pedido" json:"data_pedido,omitempty" toml:"data_pedido" yaml:"data_pedido,omitempty"`
	GMT                null.Int16        `boil:"gmt" json:"gmt,omitempty" toml:"gmt" yaml:"gmt,omitempty"`
	PedidoPronto       null.Int16        `boil:"pedido_pronto" json:"pedido_pronto,omitempty" toml:"pedido_pronto" yaml:"pedido_pronto,omitempty"`
	DataPedidoPronto   null.Time         `boil:"data_pedido_pronto" json:"data_pedido_pronto,omitempty" toml:"data_pedido_pronto" yaml:"data_pedido_pronto,omitempty"`
	Cupom              null.String       `boil:"cupom" json:"cupom,omitempty" toml:"cupom" yaml:"cupom,omitempty"`
	TipoEntrega        null.String       `boil:"tipo_entrega" json:"tipo_entrega,omitempty" toml:"tipo_entrega" yaml:"tipo_entrega,omitempty"`
	Prazo              null.Int          `boil:"prazo" json:"prazo,omitempty" toml:"prazo" yaml:"prazo,omitempty"`
	PrazoMin           null.Int          `boil:"prazo_min" json:"prazo_min,omitempty" toml:"prazo_min" yaml:"prazo_min,omitempty"`
	PrazoMax           null.Int          `boil:"prazo_max" json:"prazo_max,omitempty" toml:"prazo_max" yaml:"prazo_max,omitempty"`
	CategoriaPagamento null.String       `boil:"categoria_pagamento" json:"categoria_pagamento,omitempty" toml:"categoria_pagamento" yaml:"categoria_pagamento,omitempty"`
	FormaPagamento     null.String       `boil:"forma_pagamento" json:"forma_pagamento,omitempty" toml:"forma_pagamento" yaml:"forma_pagamento,omitempty"`
	ValorTotal         types.NullDecimal `boil:"valor_total" json:"valor_total,omitempty" toml:"valor_total" yaml:"valor_total,omitempty"`
	Observacao         null.String       `boil:"observacao" json:"observacao,omitempty" toml:"observacao" yaml:"observacao,omitempty"`
	TaxaEntrega        types.NullDecimal `boil:"taxa_entrega" json:"taxa_entrega,omitempty" toml:"taxa_entrega" yaml:"taxa_entrega,omitempty"`
	NomeTaxaEntrega    null.String       `boil:"nome_taxa_entrega" json:"nome_taxa_entrega,omitempty" toml:"nome_taxa_entrega" yaml:"nome_taxa_entrega,omitempty"`
	IDStatus           null.Int16        `boil:"id_status" json:"id_status,omitempty" toml:"id_status" yaml:"id_status,omitempty"`
	Lat                types.NullDecimal `boil:"lat" json:"lat,omitempty" toml:"lat" yaml:"lat,omitempty"`
	LNG                types.NullDecimal `boil:"lng" json:"lng,omitempty" toml:"lng" yaml:"lng,omitempty"`
	CreatedAt          null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt          null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt          null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
}

var PedidosViewColumns = struct {
	ID                 string
	SeqID              string
	TenantID           string
	IDCliente          string
	CodigoPedido       string
	DataPedido         string
	GMT                string
	PedidoPronto       string
	DataPedidoPronto   string
	Cupom              string
	TipoEntrega        string
	Prazo              string
	PrazoMin           string
	PrazoMax           string
	CategoriaPagamento string
	FormaPagamento     string
	ValorTotal         string
	Observacao         string
	TaxaEntrega        string
	NomeTaxaEntrega    string
	IDStatus           string
	Lat                string
	LNG                string
	CreatedAt          string
	UpdatedAt          string
	DeletedAt          string
}{
	ID:                 "id",
	SeqID:              "seq_id",
	TenantID:           "tenant_id",
	IDCliente:          "id_cliente",
	CodigoPedido:       "codigo_pedido",
	DataPedido:         "data_pedido",
	GMT:                "gmt",
	PedidoPronto:       "pedido_pronto",
	DataPedidoPronto:   "data_pedido_pronto",
	Cupom:              "cupom",
	TipoEntrega:        "tipo_entrega",
	Prazo:              "prazo",
	PrazoMin:           "prazo_min",
	PrazoMax:           "prazo_max",
	CategoriaPagamento: "categoria_pagamento",
	FormaPagamento:     "forma_pagamento",
	ValorTotal:         "valor_total",
	Observacao:         "observacao",
	TaxaEntrega:        "taxa_entrega",
	NomeTaxaEntrega:    "nome_taxa_entrega",
	IDStatus:           "id_status",
	Lat:                "lat",
	LNG:                "lng",
	CreatedAt:          "created_at",
	UpdatedAt:          "updated_at",
	DeletedAt:          "deleted_at",
}

var PedidosViewTableColumns = struct {
	ID                 string
	SeqID              string
	TenantID           string
	IDCliente          string
	CodigoPedido       string
	DataPedido         string
	GMT                string
	PedidoPronto       string
	DataPedidoPronto   string
	Cupom              string
	TipoEntrega        string
	Prazo              string
	PrazoMin           string
	PrazoMax           string
	CategoriaPagamento string
	FormaPagamento     string
	ValorTotal         string
	Observacao         string
	TaxaEntrega        string
	NomeTaxaEntrega    string
	IDStatus           string
	Lat                string
	LNG                string
	CreatedAt          string
	UpdatedAt          string
	DeletedAt          string
}{
	ID:                 "pedidos_view.id",
	SeqID:              "pedidos_view.seq_id",
	TenantID:           "pedidos_view.tenant_id",
	IDCliente:          "pedidos_view.id_cliente",
	CodigoPedido:       "pedidos_view.codigo_pedido",
	DataPedido:         "pedidos_view.data_pedido",
	GMT:                "pedidos_view.gmt",
	PedidoPronto:       "pedidos_view.pedido_pronto",
	DataPedidoPronto:   "pedidos_view.data_pedido_pronto",
	Cupom:              "pedidos_view.cupom",
	TipoEntrega:        "pedidos_view.tipo_entrega",
	Prazo:              "pedidos_view.prazo",
	PrazoMin:           "pedidos_view.prazo_min",
	PrazoMax:           "pedidos_view.prazo_max",
	CategoriaPagamento: "pedidos_view.categoria_pagamento",
	FormaPagamento:     "pedidos_view.forma_pagamento",
	ValorTotal:         "pedidos_view.valor_total",
	Observacao:         "pedidos_view.observacao",
	TaxaEntrega:        "pedidos_view.taxa_entrega",
	NomeTaxaEntrega:    "pedidos_view.nome_taxa_entrega",
	IDStatus:           "pedidos_view.id_status",
	Lat:                "pedidos_view.lat",
	LNG:                "pedidos_view.lng",
	CreatedAt:          "pedidos_view.created_at",
	UpdatedAt:          "pedidos_view.updated_at",
	DeletedAt:          "pedidos_view.deleted_at",
}

// Generated where

var PedidosViewWhere = struct {
	ID                 whereHelpernull_String
	SeqID              whereHelpernull_Int64
	TenantID           whereHelpernull_String
	IDCliente          whereHelpernull_String
	CodigoPedido       whereHelpernull_String
	DataPedido         whereHelpernull_Time
	GMT                whereHelpernull_Int16
	PedidoPronto       whereHelpernull_Int16
	DataPedidoPronto   whereHelpernull_Time
	Cupom              whereHelpernull_String
	TipoEntrega        whereHelpernull_String
	Prazo              whereHelpernull_Int
	PrazoMin           whereHelpernull_Int
	PrazoMax           whereHelpernull_Int
	CategoriaPagamento whereHelpernull_String
	FormaPagamento     whereHelpernull_String
	ValorTotal         whereHelpertypes_NullDecimal
	Observacao         whereHelpernull_String
	TaxaEntrega        whereHelpertypes_NullDecimal
	NomeTaxaEntrega    whereHelpernull_String
	IDStatus           whereHelpernull_Int16
	Lat                whereHelpertypes_NullDecimal
	LNG                whereHelpertypes_NullDecimal
	CreatedAt          whereHelpernull_Time
	UpdatedAt          whereHelpernull_Time
	DeletedAt          whereHelpernull_Time
}{
	ID:                 whereHelpernull_String{field: "\"pedidos_view\".\"id\""},
	SeqID:              whereHelpernull_Int64{field: "\"pedidos_view\".\"seq_id\""},
	TenantID:           whereHelpernull_String{field: "\"pedidos_view\".\"tenant_id\""},
	IDCliente:          whereHelpernull_String{field: "\"pedidos_view\".\"id_cliente\""},
	CodigoPedido:       whereHelpernull_String{field: "\"pedidos_view\".\"codigo_pedido\""},
	DataPedido:         whereHelpernull_Time{field: "\"pedidos_view\".\"data_pedido\""},
	GMT:                whereHelpernull_Int16{field: "\"pedidos_view\".\"gmt\""},
	PedidoPronto:       whereHelpernull_Int16{field: "\"pedidos_view\".\"pedido_pronto\""},
	DataPedidoPronto:   whereHelpernull_Time{field: "\"pedidos_view\".\"data_pedido_pronto\""},
	Cupom:              whereHelpernull_String{field: "\"pedidos_view\".\"cupom\""},
	TipoEntrega:        whereHelpernull_String{field: "\"pedidos_view\".\"tipo_entrega\""},
	Prazo:              whereHelpernull_Int{field: "\"pedidos_view\".\"prazo\""},
	PrazoMin:           whereHelpernull_Int{field: "\"pedidos_view\".\"prazo_min\""},
	PrazoMax:           whereHelpernull_Int{field: "\"pedidos_view\".\"prazo_max\""},
	CategoriaPagamento: whereHelpernull_String{field: "\"pedidos_view\".\"categoria_pagamento\""},
	FormaPagamento:     whereHelpernull_String{field: "\"pedidos_view\".\"forma_pagamento\""},
	ValorTotal:         whereHelpertypes_NullDecimal{field: "\"pedidos_view\".\"valor_total\""},
	Observacao:         whereHelpernull_String{field: "\"pedidos_view\".\"observacao\""},
	TaxaEntrega:        whereHelpertypes_NullDecimal{field: "\"pedidos_view\".\"taxa_entrega\""},
	NomeTaxaEntrega:    whereHelpernull_String{field: "\"pedidos_view\".\"nome_taxa_entrega\""},
	IDStatus:           whereHelpernull_Int16{field: "\"pedidos_view\".\"id_status\""},
	Lat:                whereHelpertypes_NullDecimal{field: "\"pedidos_view\".\"lat\""},
	LNG:                whereHelpertypes_NullDecimal{field: "\"pedidos_view\".\"lng\""},
	CreatedAt:          whereHelpernull_Time{field: "\"pedidos_view\".\"created_at\""},
	UpdatedAt:          whereHelpernull_Time{field: "\"pedidos_view\".\"updated_at\""},
	DeletedAt:          whereHelpernull_Time{field: "\"pedidos_view\".\"deleted_at\""},
}

var (
	pedidosViewAllColumns            = []string{"id", "seq_id", "tenant_id", "id_cliente", "codigo_pedido", "data_pedido", "gmt", "pedido_pronto", "data_pedido_pronto", "cupom", "tipo_entrega", "prazo", "prazo_min", "prazo_max", "categoria_pagamento", "forma_pagamento", "valor_total", "observacao", "taxa_entrega", "nome_taxa_entrega", "id_status", "lat", "lng", "created_at", "updated_at", "deleted_at"}
	pedidosViewColumnsWithoutDefault = []string{}
	pedidosViewColumnsWithDefault    = []string{"id", "seq_id", "tenant_id", "id_cliente", "codigo_pedido", "data_pedido", "gmt", "pedido_pronto", "data_pedido_pronto", "cupom", "tipo_entrega", "prazo", "prazo_min", "prazo_max", "categoria_pagamento", "forma_pagamento", "valor_total", "observacao", "taxa_entrega", "nome_taxa_entrega", "id_status", "lat", "lng", "created_at", "updated_at", "deleted_at"}
	pedidosViewPrimaryKeyColumns     = []string{}
	pedidosViewGeneratedColumns      = []string{}
)

type (
	// PedidosViewSlice is an alias for a slice of pointers to PedidosView.
	// This should almost always be used instead of []PedidosView.
	PedidosViewSlice []*PedidosView
	// PedidosViewHook is the signature for custom PedidosView hook methods
	PedidosViewHook func(context.Context, boil.ContextExecutor, *PedidosView) error

	pedidosViewQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	pedidosViewType           = reflect.TypeOf(&PedidosView{})
	pedidosViewMapping        = queries.MakeStructMapping(pedidosViewType)
	pedidosViewInsertCacheMut sync.RWMutex
	pedidosViewInsertCache    = make(map[string]insertCache)
	pedidosViewUpdateCacheMut sync.RWMutex
	pedidosViewUpdateCache    = make(map[string]updateCache)
	pedidosViewUpsertCacheMut sync.RWMutex
	pedidosViewUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var pedidosViewAfterSelectMu sync.Mutex
var pedidosViewAfterSelectHooks []PedidosViewHook

var pedidosViewBeforeInsertMu sync.Mutex
var pedidosViewBeforeInsertHooks []PedidosViewHook
var pedidosViewAfterInsertMu sync.Mutex
var pedidosViewAfterInsertHooks []PedidosViewHook

var pedidosViewBeforeUpsertMu sync.Mutex
var pedidosViewBeforeUpsertHooks []PedidosViewHook
var pedidosViewAfterUpsertMu sync.Mutex
var pedidosViewAfterUpsertHooks []PedidosViewHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PedidosView) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range pedidosViewAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *PedidosView) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range pedidosViewBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *PedidosView) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range pedidosViewAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *PedidosView) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range pedidosViewBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *PedidosView) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range pedidosViewAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPedidosViewHook registers your hook function for all future operations.
func AddPedidosViewHook(hookPoint boil.HookPoint, pedidosViewHook PedidosViewHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		pedidosViewAfterSelectMu.Lock()
		pedidosViewAfterSelectHooks = append(pedidosViewAfterSelectHooks, pedidosViewHook)
		pedidosViewAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		pedidosViewBeforeInsertMu.Lock()
		pedidosViewBeforeInsertHooks = append(pedidosViewBeforeInsertHooks, pedidosViewHook)
		pedidosViewBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		pedidosViewAfterInsertMu.Lock()
		pedidosViewAfterInsertHooks = append(pedidosViewAfterInsertHooks, pedidosViewHook)
		pedidosViewAfterInsertMu.Unlock()
	case boil.BeforeUpsertHook:
		pedidosViewBeforeUpsertMu.Lock()
		pedidosViewBeforeUpsertHooks = append(pedidosViewBeforeUpsertHooks, pedidosViewHook)
		pedidosViewBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		pedidosViewAfterUpsertMu.Lock()
		pedidosViewAfterUpsertHooks = append(pedidosViewAfterUpsertHooks, pedidosViewHook)
		pedidosViewAfterUpsertMu.Unlock()
	}
}

// One returns a single pedidosView record from the query.
func (q pedidosViewQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PedidosView, error) {
	o := &PedidosView{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models_sql_boiler: failed to execute a one query for pedidos_view")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PedidosView records from the query.
func (q pedidosViewQuery) All(ctx context.Context, exec boil.ContextExecutor) (PedidosViewSlice, error) {
	var o []*PedidosView

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models_sql_boiler: failed to assign all query results to PedidosView slice")
	}

	if len(pedidosViewAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PedidosView records in the query.
func (q pedidosViewQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to count pedidos_view rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q pedidosViewQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models_sql_boiler: failed to check if pedidos_view exists")
	}

	return count > 0, nil
}

// PedidosViews retrieves all the records using an executor.
func PedidosViews(mods ...qm.QueryMod) pedidosViewQuery {
	mods = append(mods, qm.From("\"pedidos_view\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"pedidos_view\".*"})
	}

	return pedidosViewQuery{q}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PedidosView) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models_sql_boiler: no pedidos_view provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(pedidosViewColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	pedidosViewInsertCacheMut.RLock()
	cache, cached := pedidosViewInsertCache[key]
	pedidosViewInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			pedidosViewAllColumns,
			pedidosViewColumnsWithDefault,
			pedidosViewColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(pedidosViewType, pedidosViewMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(pedidosViewType, pedidosViewMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"pedidos_view\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"pedidos_view\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to insert into pedidos_view")
	}

	if !cached {
		pedidosViewInsertCacheMut.Lock()
		pedidosViewInsertCache[key] = cache
		pedidosViewInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PedidosView) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models_sql_boiler: no pedidos_view provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(pedidosViewColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	pedidosViewUpsertCacheMut.RLock()
	cache, cached := pedidosViewUpsertCache[key]
	pedidosViewUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			pedidosViewAllColumns,
			pedidosViewColumnsWithDefault,
			pedidosViewColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			pedidosViewAllColumns,
			pedidosViewPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models_sql_boiler: unable to upsert pedidos_view, could not build update column list")
		}

		ret := strmangle.SetComplement(pedidosViewAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(pedidosViewPrimaryKeyColumns) == 0 {
				return errors.New("models_sql_boiler: unable to upsert pedidos_view, could not build conflict column list")
			}

			conflict = make([]string, len(pedidosViewPrimaryKeyColumns))
			copy(conflict, pedidosViewPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"pedidos_view\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(pedidosViewType, pedidosViewMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(pedidosViewType, pedidosViewMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to upsert pedidos_view")
	}

	if !cached {
		pedidosViewUpsertCacheMut.Lock()
		pedidosViewUpsertCache[key] = cache
		pedidosViewUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
