// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: categoria_adicional_opcoes.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countCategoriaAdicionalOpcoesByAdicional = `-- name: CountCategoriaAdicionalOpcoesByAdicional :one
SELECT COUNT(*)
FROM categoria_adicional_opcoes
WHERE id_categoria_adicional = $1
  AND deleted_at IS NULL
`

func (q *Queries) CountCategoriaAdicionalOpcoesByAdicional(ctx context.Context, idCategoriaAdicional uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCategoriaAdicionalOpcoesByAdicional, idCategoriaAdicional)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategoriaAdicionalOpcao = `-- name: CreateCategoriaAdicionalOpcao :one

INSERT INTO categoria_adicional_opcoes (
    id_categoria_adicional,
    codigo,
    nome,
    valor,
    status
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, seq_id, id_categoria_adicional, codigo, nome,
          valor, status, created_at, updated_at
`

type CreateCategoriaAdicionalOpcaoParams struct {
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
}

type CreateCategoriaAdicionalOpcaoRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

// *****************************
// CATEGORIA_ADICIONAL_OPCOES
// *****************************
func (q *Queries) CreateCategoriaAdicionalOpcao(ctx context.Context, arg CreateCategoriaAdicionalOpcaoParams) (CreateCategoriaAdicionalOpcaoRow, error) {
	row := q.db.QueryRow(ctx, createCategoriaAdicionalOpcao,
		arg.IDCategoriaAdicional,
		arg.Codigo,
		arg.Nome,
		arg.Valor,
		arg.Status,
	)
	var i CreateCategoriaAdicionalOpcaoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoriaAdicional,
		&i.Codigo,
		&i.Nome,
		&i.Valor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoriaAdicionalOpcao = `-- name: GetCategoriaAdicionalOpcao :one
SELECT
    cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
    cao.nome, cao.valor, cao.status,
    cao.created_at, cao.updated_at,
    c.id_tenant
FROM categoria_adicional_opcoes cao
JOIN categoria_adicionais       ca  ON cao.id_categoria_adicional = ca.id
JOIN categorias                 c   ON ca.id_categoria            = c.id
WHERE cao.id = $1
  AND cao.deleted_at IS NULL
`

type GetCategoriaAdicionalOpcaoRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	IDTenant             uuid.UUID      `json:"id_tenant"`
}

func (q *Queries) GetCategoriaAdicionalOpcao(ctx context.Context, id uuid.UUID) (GetCategoriaAdicionalOpcaoRow, error) {
	row := q.db.QueryRow(ctx, getCategoriaAdicionalOpcao, id)
	var i GetCategoriaAdicionalOpcaoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoriaAdicional,
		&i.Codigo,
		&i.Nome,
		&i.Valor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IDTenant,
	)
	return i, err
}

const getCategoriaAdicionalOpcaoByCodigoAndTenant = `-- name: GetCategoriaAdicionalOpcaoByCodigoAndTenant :one
SELECT
    cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
    cao.nome, cao.valor, cao.status,
    cao.created_at, cao.updated_at,
    c.id_tenant
FROM categoria_adicional_opcoes cao
JOIN categoria_adicionais       ca  ON cao.id_categoria_adicional = ca.id
JOIN categorias                 c   ON ca.id_categoria            = c.id
WHERE cao.codigo     = $1
  AND c.id_tenant    = $2
  AND cao.deleted_at IS NULL
`

type GetCategoriaAdicionalOpcaoByCodigoAndTenantParams struct {
	Codigo   pgtype.Text `json:"codigo"`
	IDTenant uuid.UUID   `json:"id_tenant"`
}

type GetCategoriaAdicionalOpcaoByCodigoAndTenantRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	IDTenant             uuid.UUID      `json:"id_tenant"`
}

func (q *Queries) GetCategoriaAdicionalOpcaoByCodigoAndTenant(ctx context.Context, arg GetCategoriaAdicionalOpcaoByCodigoAndTenantParams) (GetCategoriaAdicionalOpcaoByCodigoAndTenantRow, error) {
	row := q.db.QueryRow(ctx, getCategoriaAdicionalOpcaoByCodigoAndTenant, arg.Codigo, arg.IDTenant)
	var i GetCategoriaAdicionalOpcaoByCodigoAndTenantRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoriaAdicional,
		&i.Codigo,
		&i.Nome,
		&i.Valor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IDTenant,
	)
	return i, err
}

const getCategoriaAdicionalOpcaoBySeqID = `-- name: GetCategoriaAdicionalOpcaoBySeqID :one
SELECT
    cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
    cao.nome, cao.valor, cao.status,
    cao.created_at, cao.updated_at,
    c.id_tenant
FROM categoria_adicional_opcoes cao
JOIN categoria_adicionais       ca  ON cao.id_categoria_adicional = ca.id
JOIN categorias                 c   ON ca.id_categoria            = c.id
WHERE cao.seq_id = $1
  AND cao.deleted_at IS NULL
`

type GetCategoriaAdicionalOpcaoBySeqIDRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	IDTenant             uuid.UUID      `json:"id_tenant"`
}

func (q *Queries) GetCategoriaAdicionalOpcaoBySeqID(ctx context.Context, seqID int64) (GetCategoriaAdicionalOpcaoBySeqIDRow, error) {
	row := q.db.QueryRow(ctx, getCategoriaAdicionalOpcaoBySeqID, seqID)
	var i GetCategoriaAdicionalOpcaoBySeqIDRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoriaAdicional,
		&i.Codigo,
		&i.Nome,
		&i.Valor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IDTenant,
	)
	return i, err
}

const hardDeleteCategoriaAdicionalOpcao = `-- name: HardDeleteCategoriaAdicionalOpcao :exec
DELETE FROM categoria_adicional_opcoes cao
USING categoria_adicionais ca
JOIN categorias       c ON ca.id_categoria = c.id
WHERE cao.id_categoria_adicional = ca.id
  AND cao.id       = $1
  AND c.id_tenant  = $2
`

type HardDeleteCategoriaAdicionalOpcaoParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

func (q *Queries) HardDeleteCategoriaAdicionalOpcao(ctx context.Context, arg HardDeleteCategoriaAdicionalOpcaoParams) error {
	_, err := q.db.Exec(ctx, hardDeleteCategoriaAdicionalOpcao, arg.ID, arg.IDTenant)
	return err
}

const listCategoriaAdicionalOpcoesByAdicional = `-- name: ListCategoriaAdicionalOpcoesByAdicional :many
SELECT
    cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
    cao.nome, cao.valor, cao.status,
    cao.created_at, cao.updated_at
FROM categoria_adicional_opcoes cao
WHERE cao.id_categoria_adicional = $1
  AND cao.deleted_at IS NULL
ORDER BY cao.nome
LIMIT  $2 OFFSET $3
`

type ListCategoriaAdicionalOpcoesByAdicionalParams struct {
	IDCategoriaAdicional uuid.UUID `json:"id_categoria_adicional"`
	Limit                int32     `json:"limit"`
	Offset               int32     `json:"offset"`
}

type ListCategoriaAdicionalOpcoesByAdicionalRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) ListCategoriaAdicionalOpcoesByAdicional(ctx context.Context, arg ListCategoriaAdicionalOpcoesByAdicionalParams) ([]ListCategoriaAdicionalOpcoesByAdicionalRow, error) {
	rows, err := q.db.Query(ctx, listCategoriaAdicionalOpcoesByAdicional, arg.IDCategoriaAdicional, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriaAdicionalOpcoesByAdicionalRow
	for rows.Next() {
		var i ListCategoriaAdicionalOpcoesByAdicionalRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.IDCategoriaAdicional,
			&i.Codigo,
			&i.Nome,
			&i.Valor,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriaAdicionalOpcoesByTenant = `-- name: ListCategoriaAdicionalOpcoesByTenant :many
SELECT
    cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
    cao.nome, cao.valor, cao.status,
    cao.created_at, cao.updated_at,
    c.id_tenant
FROM categoria_adicional_opcoes cao
JOIN categoria_adicionais       ca  ON cao.id_categoria_adicional = ca.id
JOIN categorias                 c   ON ca.id_categoria            = c.id
WHERE c.id_tenant    = $1
  AND cao.deleted_at IS NULL
ORDER BY ca.nome, cao.nome
LIMIT  $2 OFFSET $3
`

type ListCategoriaAdicionalOpcoesByTenantParams struct {
	IDTenant uuid.UUID `json:"id_tenant"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListCategoriaAdicionalOpcoesByTenantRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	IDTenant             uuid.UUID      `json:"id_tenant"`
}

func (q *Queries) ListCategoriaAdicionalOpcoesByTenant(ctx context.Context, arg ListCategoriaAdicionalOpcoesByTenantParams) ([]ListCategoriaAdicionalOpcoesByTenantRow, error) {
	rows, err := q.db.Query(ctx, listCategoriaAdicionalOpcoesByTenant, arg.IDTenant, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriaAdicionalOpcoesByTenantRow
	for rows.Next() {
		var i ListCategoriaAdicionalOpcoesByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.IDCategoriaAdicional,
			&i.Codigo,
			&i.Nome,
			&i.Valor,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IDTenant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreCategoriaAdicionalOpcao = `-- name: RestoreCategoriaAdicionalOpcao :one
UPDATE categoria_adicional_opcoes cao
SET deleted_at = NULL,
    updated_at = now()
FROM categoria_adicionais ca
JOIN categorias       c ON ca.id_categoria = c.id
WHERE cao.id_categoria_adicional = ca.id
  AND cao.id       = $1
  AND c.id_tenant  = $2
  AND cao.deleted_at IS NOT NULL
RETURNING cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
          cao.nome, cao.valor, cao.status,
          cao.created_at, cao.updated_at
`

type RestoreCategoriaAdicionalOpcaoParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

type RestoreCategoriaAdicionalOpcaoRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) RestoreCategoriaAdicionalOpcao(ctx context.Context, arg RestoreCategoriaAdicionalOpcaoParams) (RestoreCategoriaAdicionalOpcaoRow, error) {
	row := q.db.QueryRow(ctx, restoreCategoriaAdicionalOpcao, arg.ID, arg.IDTenant)
	var i RestoreCategoriaAdicionalOpcaoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoriaAdicional,
		&i.Codigo,
		&i.Nome,
		&i.Valor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const softDeleteCategoriaAdicionalOpcao = `-- name: SoftDeleteCategoriaAdicionalOpcao :exec
UPDATE categoria_adicional_opcoes cao
SET deleted_at = now()
FROM categoria_adicionais ca
JOIN categorias       c ON ca.id_categoria = c.id
WHERE cao.id_categoria_adicional = ca.id
  AND cao.id       = $1
  AND c.id_tenant  = $2
  AND cao.deleted_at IS NULL
`

type SoftDeleteCategoriaAdicionalOpcaoParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

func (q *Queries) SoftDeleteCategoriaAdicionalOpcao(ctx context.Context, arg SoftDeleteCategoriaAdicionalOpcaoParams) error {
	_, err := q.db.Exec(ctx, softDeleteCategoriaAdicionalOpcao, arg.ID, arg.IDTenant)
	return err
}

const updateCategoriaAdicionalOpcao = `-- name: UpdateCategoriaAdicionalOpcao :one
UPDATE categoria_adicional_opcoes cao
SET
    id_categoria_adicional = $3,
    codigo   = $4,
    nome     = $5,
    valor    = $6,
    status   = $7,
    updated_at = now()
FROM categoria_adicionais ca
JOIN categorias       c ON ca.id_categoria = c.id
WHERE cao.id_categoria_adicional = ca.id
  AND cao.id       = $1
  AND c.id_tenant  = $2
  AND cao.deleted_at IS NULL
RETURNING cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
          cao.nome, cao.valor, cao.status,
          cao.created_at, cao.updated_at
`

type UpdateCategoriaAdicionalOpcaoParams struct {
	ID                   uuid.UUID      `json:"id"`
	IDTenant             uuid.UUID      `json:"id_tenant"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
}

type UpdateCategoriaAdicionalOpcaoRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) UpdateCategoriaAdicionalOpcao(ctx context.Context, arg UpdateCategoriaAdicionalOpcaoParams) (UpdateCategoriaAdicionalOpcaoRow, error) {
	row := q.db.QueryRow(ctx, updateCategoriaAdicionalOpcao,
		arg.ID,
		arg.IDTenant,
		arg.IDCategoriaAdicional,
		arg.Codigo,
		arg.Nome,
		arg.Valor,
		arg.Status,
	)
	var i UpdateCategoriaAdicionalOpcaoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoriaAdicional,
		&i.Codigo,
		&i.Nome,
		&i.Valor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCategoriaAdicionalOpcaoStatus = `-- name: UpdateCategoriaAdicionalOpcaoStatus :one
UPDATE categoria_adicional_opcoes cao
SET
    status     = $3,
    updated_at = now()
FROM categoria_adicionais ca
JOIN categorias       c ON ca.id_categoria = c.id
WHERE cao.id_categoria_adicional = ca.id
  AND cao.id       = $1
  AND c.id_tenant  = $2
  AND cao.deleted_at IS NULL
RETURNING cao.id, cao.seq_id, cao.id_categoria_adicional, cao.codigo,
          cao.nome, cao.valor, cao.status,
          cao.created_at, cao.updated_at
`

type UpdateCategoriaAdicionalOpcaoStatusParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
	Status   int16     `json:"status"`
}

type UpdateCategoriaAdicionalOpcaoStatusRow struct {
	ID                   uuid.UUID      `json:"id"`
	SeqID                int64          `json:"seq_id"`
	IDCategoriaAdicional uuid.UUID      `json:"id_categoria_adicional"`
	Codigo               pgtype.Text    `json:"codigo"`
	Nome                 string         `json:"nome"`
	Valor                pgtype.Numeric `json:"valor"`
	Status               int16          `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) UpdateCategoriaAdicionalOpcaoStatus(ctx context.Context, arg UpdateCategoriaAdicionalOpcaoStatusParams) (UpdateCategoriaAdicionalOpcaoStatusRow, error) {
	row := q.db.QueryRow(ctx, updateCategoriaAdicionalOpcaoStatus, arg.ID, arg.IDTenant, arg.Status)
	var i UpdateCategoriaAdicionalOpcaoStatusRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoriaAdicional,
		&i.Codigo,
		&i.Nome,
		&i.Valor,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
