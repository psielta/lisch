// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: categoria.sql

package pgstore

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countCategoriasByCulinaria = `-- name: CountCategoriasByCulinaria :one
SELECT COUNT(*)
FROM categorias
WHERE id_culinaria = $1 AND id_tenant = $2 AND deleted_at IS NULL
`

type CountCategoriasByCulinariaParams struct {
	IDCulinaria int32     `json:"id_culinaria"`
	IDTenant    uuid.UUID `json:"id_tenant"`
}

func (q *Queries) CountCategoriasByCulinaria(ctx context.Context, arg CountCategoriasByCulinariaParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCategoriasByCulinaria, arg.IDCulinaria, arg.IDTenant)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategoria = `-- name: CreateCategoria :one


INSERT INTO categorias (
    id_tenant,
    id_culinaria,
    nome,
    descricao,
    inicio,
    fim,
    ativo,
    opcao_meia,
    ordem,
    disponivel_domingo,
    disponivel_segunda,
    disponivel_terca,
    disponivel_quarta,
    disponivel_quinta,
    disponivel_sexta,
    disponivel_sabado
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
         )
    RETURNING id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
  ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
  disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
`

type CreateCategoriaParams struct {
	IDTenant          uuid.UUID   `json:"id_tenant"`
	IDCulinaria       int32       `json:"id_culinaria"`
	Nome              string      `json:"nome"`
	Descricao         pgtype.Text `json:"descricao"`
	Inicio            pgtype.Time `json:"inicio"`
	Fim               pgtype.Time `json:"fim"`
	Ativo             int16       `json:"ativo"`
	OpcaoMeia         pgtype.Text `json:"opcao_meia"`
	Ordem             pgtype.Int4 `json:"ordem"`
	DisponivelDomingo int16       `json:"disponivel_domingo"`
	DisponivelSegunda int16       `json:"disponivel_segunda"`
	DisponivelTerca   int16       `json:"disponivel_terca"`
	DisponivelQuarta  int16       `json:"disponivel_quarta"`
	DisponivelQuinta  int16       `json:"disponivel_quinta"`
	DisponivelSexta   int16       `json:"disponivel_sexta"`
	DisponivelSabado  int16       `json:"disponivel_sabado"`
}

type CreateCategoriaRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// SQLC Queries para Categorias
// ***********************
// CATEGORIAS
// ***********************
func (q *Queries) CreateCategoria(ctx context.Context, arg CreateCategoriaParams) (CreateCategoriaRow, error) {
	row := q.db.QueryRow(ctx, createCategoria,
		arg.IDTenant,
		arg.IDCulinaria,
		arg.Nome,
		arg.Descricao,
		arg.Inicio,
		arg.Fim,
		arg.Ativo,
		arg.OpcaoMeia,
		arg.Ordem,
		arg.DisponivelDomingo,
		arg.DisponivelSegunda,
		arg.DisponivelTerca,
		arg.DisponivelQuarta,
		arg.DisponivelQuinta,
		arg.DisponivelSexta,
		arg.DisponivelSabado,
	)
	var i CreateCategoriaRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoria = `-- name: GetCategoria :one
SELECT
    id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
    ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
    disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
FROM categorias
WHERE id = $1 AND deleted_at IS NULL
`

type GetCategoriaRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCategoria(ctx context.Context, id uuid.UUID) (GetCategoriaRow, error) {
	row := q.db.QueryRow(ctx, getCategoria, id)
	var i GetCategoriaRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoriaByNome = `-- name: GetCategoriaByNome :one
SELECT
    id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
    ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
    disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
FROM categorias
WHERE nome = $1 AND id_tenant = $2 AND deleted_at IS NULL
`

type GetCategoriaByNomeParams struct {
	Nome     string    `json:"nome"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

type GetCategoriaByNomeRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCategoriaByNome(ctx context.Context, arg GetCategoriaByNomeParams) (GetCategoriaByNomeRow, error) {
	row := q.db.QueryRow(ctx, getCategoriaByNome, arg.Nome, arg.IDTenant)
	var i GetCategoriaByNomeRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoriaBySeqID = `-- name: GetCategoriaBySeqID :one
SELECT
    id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
    ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
    disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
FROM categorias
WHERE seq_id = $1 AND deleted_at IS NULL
`

type GetCategoriaBySeqIDRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCategoriaBySeqID(ctx context.Context, seqID pgtype.Int8) (GetCategoriaBySeqIDRow, error) {
	row := q.db.QueryRow(ctx, getCategoriaBySeqID, seqID)
	var i GetCategoriaBySeqIDRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hardDeleteCategoria = `-- name: HardDeleteCategoria :exec
DELETE FROM categorias
WHERE id = $1 AND id_tenant = $2
`

type HardDeleteCategoriaParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

func (q *Queries) HardDeleteCategoria(ctx context.Context, arg HardDeleteCategoriaParams) error {
	_, err := q.db.Exec(ctx, hardDeleteCategoria, arg.ID, arg.IDTenant)
	return err
}

const listCategorias = `-- name: ListCategorias :many
SELECT
    id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
    ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
    disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
FROM categorias
WHERE id_tenant = $1 AND deleted_at IS NULL
ORDER BY ordem NULLS LAST, nome
    LIMIT $2 OFFSET $3
`

type ListCategoriasParams struct {
	IDTenant uuid.UUID `json:"id_tenant"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListCategoriasRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListCategorias(ctx context.Context, arg ListCategoriasParams) ([]ListCategoriasRow, error) {
	rows, err := q.db.Query(ctx, listCategorias, arg.IDTenant, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriasRow
	for rows.Next() {
		var i ListCategoriasRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.IDTenant,
			&i.IDCulinaria,
			&i.Nome,
			&i.Descricao,
			&i.Inicio,
			&i.Fim,
			&i.Ativo,
			&i.OpcaoMeia,
			&i.Ordem,
			&i.DisponivelDomingo,
			&i.DisponivelSegunda,
			&i.DisponivelTerca,
			&i.DisponivelQuarta,
			&i.DisponivelQuinta,
			&i.DisponivelSexta,
			&i.DisponivelSabado,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriasByCulinaria = `-- name: ListCategoriasByCulinaria :many
SELECT
    id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
    ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
    disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
FROM categorias
WHERE id_tenant = $1 AND id_culinaria = $2 AND deleted_at IS NULL
ORDER BY ordem NULLS LAST, nome
    LIMIT $3 OFFSET $4
`

type ListCategoriasByCulinariaParams struct {
	IDTenant    uuid.UUID `json:"id_tenant"`
	IDCulinaria int32     `json:"id_culinaria"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListCategoriasByCulinariaRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListCategoriasByCulinaria(ctx context.Context, arg ListCategoriasByCulinariaParams) ([]ListCategoriasByCulinariaRow, error) {
	rows, err := q.db.Query(ctx, listCategoriasByCulinaria,
		arg.IDTenant,
		arg.IDCulinaria,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriasByCulinariaRow
	for rows.Next() {
		var i ListCategoriasByCulinariaRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.IDTenant,
			&i.IDCulinaria,
			&i.Nome,
			&i.Descricao,
			&i.Inicio,
			&i.Fim,
			&i.Ativo,
			&i.OpcaoMeia,
			&i.Ordem,
			&i.DisponivelDomingo,
			&i.DisponivelSegunda,
			&i.DisponivelTerca,
			&i.DisponivelQuarta,
			&i.DisponivelQuinta,
			&i.DisponivelSexta,
			&i.DisponivelSabado,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriasDisponiveis = `-- name: ListCategoriasDisponiveis :many
SELECT
    id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
    ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
    disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
FROM categorias
WHERE
    id_tenant = $1 AND
    ativo = 1 AND
    deleted_at IS NULL AND
    (
        (EXTRACT(DOW FROM $2::timestamp) = 0 AND disponivel_domingo = 1) OR
        (EXTRACT(DOW FROM $2::timestamp) = 1 AND disponivel_segunda = 1) OR
        (EXTRACT(DOW FROM $2::timestamp) = 2 AND disponivel_terca = 1) OR
        (EXTRACT(DOW FROM $2::timestamp) = 3 AND disponivel_quarta = 1) OR
        (EXTRACT(DOW FROM $2::timestamp) = 4 AND disponivel_quinta = 1) OR
        (EXTRACT(DOW FROM $2::timestamp) = 5 AND disponivel_sexta = 1) OR
        (EXTRACT(DOW FROM $2::timestamp) = 6 AND disponivel_sabado = 1)
        ) AND
    ($2::time >= inicio OR inicio = '00:00:00') AND
    ($2::time <= fim OR fim = '00:00:00')
ORDER BY ordem NULLS LAST, nome
`

type ListCategoriasDisponiveisParams struct {
	IDTenant uuid.UUID        `json:"id_tenant"`
	Column2  pgtype.Timestamp `json:"column_2"`
}

type ListCategoriasDisponiveisRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListCategoriasDisponiveis(ctx context.Context, arg ListCategoriasDisponiveisParams) ([]ListCategoriasDisponiveisRow, error) {
	rows, err := q.db.Query(ctx, listCategoriasDisponiveis, arg.IDTenant, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriasDisponiveisRow
	for rows.Next() {
		var i ListCategoriasDisponiveisRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.IDTenant,
			&i.IDCulinaria,
			&i.Nome,
			&i.Descricao,
			&i.Inicio,
			&i.Fim,
			&i.Ativo,
			&i.OpcaoMeia,
			&i.Ordem,
			&i.DisponivelDomingo,
			&i.DisponivelSegunda,
			&i.DisponivelTerca,
			&i.DisponivelQuarta,
			&i.DisponivelQuinta,
			&i.DisponivelSexta,
			&i.DisponivelSabado,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreCategoria = `-- name: RestoreCategoria :one
UPDATE categorias
SET deleted_at = NULL
WHERE id = $1 AND id_tenant = $2
    RETURNING id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
  ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
  disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
`

type RestoreCategoriaParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

type RestoreCategoriaRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) RestoreCategoria(ctx context.Context, arg RestoreCategoriaParams) (RestoreCategoriaRow, error) {
	row := q.db.QueryRow(ctx, restoreCategoria, arg.ID, arg.IDTenant)
	var i RestoreCategoriaRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const softDeleteCategoria = `-- name: SoftDeleteCategoria :exec
UPDATE categorias
SET deleted_at = now()
WHERE id = $1 AND id_tenant = $2 AND deleted_at IS NULL
`

type SoftDeleteCategoriaParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

func (q *Queries) SoftDeleteCategoria(ctx context.Context, arg SoftDeleteCategoriaParams) error {
	_, err := q.db.Exec(ctx, softDeleteCategoria, arg.ID, arg.IDTenant)
	return err
}

const updateCategoria = `-- name: UpdateCategoria :one
UPDATE categorias
SET
    id_culinaria = $3,
    nome = $4,
    descricao = $5,
    inicio = $6,
    fim = $7,
    ativo = $8,
    opcao_meia = $9,
    ordem = $10,
    disponivel_domingo = $11,
    disponivel_segunda = $12,
    disponivel_terca = $13,
    disponivel_quarta = $14,
    disponivel_quinta = $15,
    disponivel_sexta = $16,
    disponivel_sabado = $17,
    updated_at = now()
WHERE id = $1 AND id_tenant = $2 AND deleted_at IS NULL
    RETURNING id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
  ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
  disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
`

type UpdateCategoriaParams struct {
	ID                uuid.UUID   `json:"id"`
	IDTenant          uuid.UUID   `json:"id_tenant"`
	IDCulinaria       int32       `json:"id_culinaria"`
	Nome              string      `json:"nome"`
	Descricao         pgtype.Text `json:"descricao"`
	Inicio            pgtype.Time `json:"inicio"`
	Fim               pgtype.Time `json:"fim"`
	Ativo             int16       `json:"ativo"`
	OpcaoMeia         pgtype.Text `json:"opcao_meia"`
	Ordem             pgtype.Int4 `json:"ordem"`
	DisponivelDomingo int16       `json:"disponivel_domingo"`
	DisponivelSegunda int16       `json:"disponivel_segunda"`
	DisponivelTerca   int16       `json:"disponivel_terca"`
	DisponivelQuarta  int16       `json:"disponivel_quarta"`
	DisponivelQuinta  int16       `json:"disponivel_quinta"`
	DisponivelSexta   int16       `json:"disponivel_sexta"`
	DisponivelSabado  int16       `json:"disponivel_sabado"`
}

type UpdateCategoriaRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCategoria(ctx context.Context, arg UpdateCategoriaParams) (UpdateCategoriaRow, error) {
	row := q.db.QueryRow(ctx, updateCategoria,
		arg.ID,
		arg.IDTenant,
		arg.IDCulinaria,
		arg.Nome,
		arg.Descricao,
		arg.Inicio,
		arg.Fim,
		arg.Ativo,
		arg.OpcaoMeia,
		arg.Ordem,
		arg.DisponivelDomingo,
		arg.DisponivelSegunda,
		arg.DisponivelTerca,
		arg.DisponivelQuarta,
		arg.DisponivelQuinta,
		arg.DisponivelSexta,
		arg.DisponivelSabado,
	)
	var i UpdateCategoriaRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCategoriaOrdem = `-- name: UpdateCategoriaOrdem :one
UPDATE categorias
SET
    ordem = $3,
    updated_at = now()
WHERE id = $1 AND id_tenant = $2 AND deleted_at IS NULL
    RETURNING id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
  ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
  disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
`

type UpdateCategoriaOrdemParams struct {
	ID       uuid.UUID   `json:"id"`
	IDTenant uuid.UUID   `json:"id_tenant"`
	Ordem    pgtype.Int4 `json:"ordem"`
}

type UpdateCategoriaOrdemRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCategoriaOrdem(ctx context.Context, arg UpdateCategoriaOrdemParams) (UpdateCategoriaOrdemRow, error) {
	row := q.db.QueryRow(ctx, updateCategoriaOrdem, arg.ID, arg.IDTenant, arg.Ordem)
	var i UpdateCategoriaOrdemRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCategoriaStatus = `-- name: UpdateCategoriaStatus :one
UPDATE categorias
SET
    ativo = $3,
    updated_at = now()
WHERE id = $1 AND id_tenant = $2 AND deleted_at IS NULL
    RETURNING id, seq_id, id_tenant, id_culinaria, nome, descricao, inicio, fim, ativo, opcao_meia,
  ordem, disponivel_domingo, disponivel_segunda, disponivel_terca, disponivel_quarta,
  disponivel_quinta, disponivel_sexta, disponivel_sabado, created_at, updated_at
`

type UpdateCategoriaStatusParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
	Ativo    int16     `json:"ativo"`
}

type UpdateCategoriaStatusRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
	IDCulinaria       int32              `json:"id_culinaria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	Inicio            pgtype.Time        `json:"inicio"`
	Fim               pgtype.Time        `json:"fim"`
	Ativo             int16              `json:"ativo"`
	OpcaoMeia         pgtype.Text        `json:"opcao_meia"`
	Ordem             pgtype.Int4        `json:"ordem"`
	DisponivelDomingo int16              `json:"disponivel_domingo"`
	DisponivelSegunda int16              `json:"disponivel_segunda"`
	DisponivelTerca   int16              `json:"disponivel_terca"`
	DisponivelQuarta  int16              `json:"disponivel_quarta"`
	DisponivelQuinta  int16              `json:"disponivel_quinta"`
	DisponivelSexta   int16              `json:"disponivel_sexta"`
	DisponivelSabado  int16              `json:"disponivel_sabado"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCategoriaStatus(ctx context.Context, arg UpdateCategoriaStatusParams) (UpdateCategoriaStatusRow, error) {
	row := q.db.QueryRow(ctx, updateCategoriaStatus, arg.ID, arg.IDTenant, arg.Ativo)
	var i UpdateCategoriaStatusRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDTenant,
		&i.IDCulinaria,
		&i.Nome,
		&i.Descricao,
		&i.Inicio,
		&i.Fim,
		&i.Ativo,
		&i.OpcaoMeia,
		&i.Ordem,
		&i.DisponivelDomingo,
		&i.DisponivelSegunda,
		&i.DisponivelTerca,
		&i.DisponivelQuarta,
		&i.DisponivelQuinta,
		&i.DisponivelSexta,
		&i.DisponivelSabado,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
