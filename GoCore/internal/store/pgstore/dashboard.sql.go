// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dashboard.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getPagamentosDetalhadosUlt3Meses = `-- name: GetPagamentosDetalhadosUlt3Meses :many
/*
  Lista cada pagamento individual dos últimos 3 meses.
  Campos suficientes para o modal, sem ` + "`" + `forma_pagamento` + "`" + `.
*/
SELECT
    pp.id,
    pp.id_pedido,
    pp.categoria_pagamento,
    pp.valor_pago,
    pp.troco,
    (pp.valor_pago - COALESCE(pp.troco, 0))::numeric(12,2)          AS valor_liquido,
    (pp.created_at AT TIME ZONE 'America/Sao_Paulo')                AS created_br,
    (pp.created_at AT TIME ZONE 'America/Sao_Paulo')::date          AS dia,
    p.codigo_pedido,
    (p.data_pedido AT TIME ZONE 'America/Sao_Paulo')                AS data_pedido_br,
    c.nome_razao_social                                             AS cliente
FROM   public.pedido_pagamentos pp
JOIN   public.pedidos          p  ON p.id       = pp.id_pedido
LEFT   JOIN public.clientes     c  ON c.id       = p.id_cliente
WHERE  pp.deleted_at IS NULL
  AND  p.deleted_at  IS NULL
  AND  p.tenant_id   = $1
  AND  (pp.created_at AT TIME ZONE 'America/Sao_Paulo')::date
         >= CURRENT_DATE - INTERVAL '3 months'
ORDER BY pp.created_at DESC
`

type GetPagamentosDetalhadosUlt3MesesRow struct {
	ID                 uuid.UUID      `json:"id"`
	IDPedido           uuid.UUID      `json:"id_pedido"`
	CategoriaPagamento pgtype.Text    `json:"categoria_pagamento"`
	ValorPago          pgtype.Numeric `json:"valor_pago"`
	Troco              pgtype.Numeric `json:"troco"`
	ValorLiquido       pgtype.Numeric `json:"valor_liquido"`
	CreatedBr          interface{}    `json:"created_br"`
	Dia                pgtype.Date    `json:"dia"`
	CodigoPedido       string         `json:"codigo_pedido"`
	DataPedidoBr       interface{}    `json:"data_pedido_br"`
	Cliente            pgtype.Text    `json:"cliente"`
}

func (q *Queries) GetPagamentosDetalhadosUlt3Meses(ctx context.Context, tenantID uuid.UUID) ([]GetPagamentosDetalhadosUlt3MesesRow, error) {
	rows, err := q.db.Query(ctx, getPagamentosDetalhadosUlt3Meses, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPagamentosDetalhadosUlt3MesesRow
	for rows.Next() {
		var i GetPagamentosDetalhadosUlt3MesesRow
		if err := rows.Scan(
			&i.ID,
			&i.IDPedido,
			&i.CategoriaPagamento,
			&i.ValorPago,
			&i.Troco,
			&i.ValorLiquido,
			&i.CreatedBr,
			&i.Dia,
			&i.CodigoPedido,
			&i.DataPedidoBr,
			&i.Cliente,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPagamentosPorDiaECategoria = `-- name: GetPagamentosPorDiaECategoria :many
/*
  Pagamentos líquidos (valor_pago – troco) dos últimos 3 meses,
  agrupados por DIA e CATEGORIA de pagamento.
  • O tenant é passado no parâmetro $1.
*/
SELECT
    (pp.created_at AT TIME ZONE 'America/Sao_Paulo')::date          AS dia,
    pp.categoria_pagamento,
    SUM(pp.valor_pago - COALESCE(pp.troco, 0))::numeric(12,2)       AS valor_liquido
FROM   public.pedido_pagamentos pp
JOIN   public.pedidos          p  ON p.id = pp.id_pedido            -- garante o tenant
WHERE  pp.deleted_at IS NULL
  AND  p.deleted_at  IS NULL
  AND  p.tenant_id   = $1
  AND  (pp.created_at AT TIME ZONE 'America/Sao_Paulo')::date
         >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY dia, pp.categoria_pagamento
ORDER BY dia, pp.categoria_pagamento
`

type GetPagamentosPorDiaECategoriaRow struct {
	Dia                pgtype.Date    `json:"dia"`
	CategoriaPagamento pgtype.Text    `json:"categoria_pagamento"`
	ValorLiquido       pgtype.Numeric `json:"valor_liquido"`
}

func (q *Queries) GetPagamentosPorDiaECategoria(ctx context.Context, tenantID uuid.UUID) ([]GetPagamentosPorDiaECategoriaRow, error) {
	rows, err := q.db.Query(ctx, getPagamentosPorDiaECategoria, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPagamentosPorDiaECategoriaRow
	for rows.Next() {
		var i GetPagamentosPorDiaECategoriaRow
		if err := rows.Scan(&i.Dia, &i.CategoriaPagamento, &i.ValorLiquido); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalBrutoAndTotalPago = `-- name: GetTotalBrutoAndTotalPago :many
SELECT
    (data_pedido AT TIME ZONE 'America/Sao_Paulo')::date          AS dia,
    SUM(valor_total + COALESCE(taxa_entrega, 0) - COALESCE(desconto, 0) + COALESCE(acrescimo, 0))::numeric(12,2)        AS total_bruto,
    SUM(COALESCE(valor_pago, 0))::numeric(12,2)                                               AS total_pago
FROM  public.pedidos
WHERE deleted_at IS NULL
  AND (data_pedido AT TIME ZONE 'America/Sao_Paulo')::date
        >= CURRENT_DATE - INTERVAL '89 days'
  AND tenant_id = $1
GROUP BY dia
ORDER BY dia
`

type GetTotalBrutoAndTotalPagoRow struct {
	Dia        pgtype.Date    `json:"dia"`
	TotalBruto pgtype.Numeric `json:"total_bruto"`
	TotalPago  pgtype.Numeric `json:"total_pago"`
}

func (q *Queries) GetTotalBrutoAndTotalPago(ctx context.Context, tenantID uuid.UUID) ([]GetTotalBrutoAndTotalPagoRow, error) {
	rows, err := q.db.Query(ctx, getTotalBrutoAndTotalPago, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalBrutoAndTotalPagoRow
	for rows.Next() {
		var i GetTotalBrutoAndTotalPagoRow
		if err := rows.Scan(&i.Dia, &i.TotalBruto, &i.TotalPago); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalBrutoAndTotalPagoDetailed = `-- name: GetTotalBrutoAndTotalPagoDetailed :many
SELECT
    p.id, p.seq_id, p.tenant_id, p.id_cliente, p.codigo_pedido, p.data_pedido, p.gmt, p.pedido_pronto, p.data_pedido_pronto, p.cupom, p.tipo_entrega, p.prazo, p.prazo_min, p.prazo_max, p.categoria_pagamento, p.forma_pagamento, p.valor_total, p.observacao, p.taxa_entrega, p.nome_taxa_entrega, p.id_status, p.lat, p.lng, p.created_at, p.updated_at, p.deleted_at, p.valor_pago, p.quitado, p.troco_para, p.desconto, p.acrescimo, p.finalizado,
    (p.valor_total + COALESCE(p.taxa_entrega, 0) - COALESCE(p.desconto, 0) + COALESCE(p.acrescimo, 0))::numeric(12,2) AS valor_bruto,
    (p.data_pedido AT TIME ZONE 'America/Sao_Paulo')            AS data_pedido_br,
    (p.data_pedido AT TIME ZONE 'America/Sao_Paulo')::date      AS dia,
    s.descricao                                                 AS status_descr,
    c.nome_razao_social                                         AS cliente
FROM  public.pedidos           p
LEFT  JOIN public.pedido_status s ON s.id       = p.id_status
LEFT  JOIN public.clientes      c ON c.id       = p.id_cliente
WHERE p.deleted_at IS NULL
  AND (p.data_pedido AT TIME ZONE 'America/Sao_Paulo')::date 
        >= CURRENT_DATE - INTERVAL '89 days'
  AND p.tenant_id = $1
ORDER BY p.data_pedido DESC
`

type GetTotalBrutoAndTotalPagoDetailedRow struct {
	ID                 uuid.UUID          `json:"id"`
	SeqID              int64              `json:"seq_id"`
	TenantID           uuid.UUID          `json:"tenant_id"`
	IDCliente          uuid.UUID          `json:"id_cliente"`
	CodigoPedido       string             `json:"codigo_pedido"`
	DataPedido         time.Time          `json:"data_pedido"`
	Gmt                int16              `json:"gmt"`
	PedidoPronto       int16              `json:"pedido_pronto"`
	DataPedidoPronto   pgtype.Timestamptz `json:"data_pedido_pronto"`
	Cupom              pgtype.Text        `json:"cupom"`
	TipoEntrega        string             `json:"tipo_entrega"`
	Prazo              pgtype.Int4        `json:"prazo"`
	PrazoMin           pgtype.Int4        `json:"prazo_min"`
	PrazoMax           pgtype.Int4        `json:"prazo_max"`
	CategoriaPagamento pgtype.Text        `json:"categoria_pagamento"`
	FormaPagamento     pgtype.Text        `json:"forma_pagamento"`
	ValorTotal         pgtype.Numeric     `json:"valor_total"`
	Observacao         pgtype.Text        `json:"observacao"`
	TaxaEntrega        pgtype.Numeric     `json:"taxa_entrega"`
	NomeTaxaEntrega    pgtype.Text        `json:"nome_taxa_entrega"`
	IDStatus           int16              `json:"id_status"`
	Lat                pgtype.Numeric     `json:"lat"`
	Lng                pgtype.Numeric     `json:"lng"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	ValorPago          pgtype.Numeric     `json:"valor_pago"`
	Quitado            pgtype.Bool        `json:"quitado"`
	TrocoPara          pgtype.Numeric     `json:"troco_para"`
	Desconto           pgtype.Numeric     `json:"desconto"`
	Acrescimo          pgtype.Numeric     `json:"acrescimo"`
	Finalizado         bool               `json:"finalizado"`
	ValorBruto         pgtype.Numeric     `json:"valor_bruto"`
	DataPedidoBr       interface{}        `json:"data_pedido_br"`
	Dia                pgtype.Date        `json:"dia"`
	StatusDescr        pgtype.Text        `json:"status_descr"`
	Cliente            pgtype.Text        `json:"cliente"`
}

func (q *Queries) GetTotalBrutoAndTotalPagoDetailed(ctx context.Context, tenantID uuid.UUID) ([]GetTotalBrutoAndTotalPagoDetailedRow, error) {
	rows, err := q.db.Query(ctx, getTotalBrutoAndTotalPagoDetailed, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalBrutoAndTotalPagoDetailedRow
	for rows.Next() {
		var i GetTotalBrutoAndTotalPagoDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.TenantID,
			&i.IDCliente,
			&i.CodigoPedido,
			&i.DataPedido,
			&i.Gmt,
			&i.PedidoPronto,
			&i.DataPedidoPronto,
			&i.Cupom,
			&i.TipoEntrega,
			&i.Prazo,
			&i.PrazoMin,
			&i.PrazoMax,
			&i.CategoriaPagamento,
			&i.FormaPagamento,
			&i.ValorTotal,
			&i.Observacao,
			&i.TaxaEntrega,
			&i.NomeTaxaEntrega,
			&i.IDStatus,
			&i.Lat,
			&i.Lng,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ValorPago,
			&i.Quitado,
			&i.TrocoPara,
			&i.Desconto,
			&i.Acrescimo,
			&i.Finalizado,
			&i.ValorBruto,
			&i.DataPedidoBr,
			&i.Dia,
			&i.StatusDescr,
			&i.Cliente,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
