// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cliente.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countClientesByTenant = `-- name: CountClientesByTenant :one
SELECT COUNT(*)
FROM public.clientes
WHERE tenant_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) CountClientesByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countClientesByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countClientesPaginated = `-- name: CountClientesPaginated :one
SELECT COUNT(*) 
FROM public.clientes c
WHERE c.tenant_id = $1
  AND c.deleted_at IS NULL
  -- Filtro geral
  AND ($2 = '' OR 
       LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($2)) || '%' OR 
       LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($2)) || '%' OR
       regexp_replace(c.cpf, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($2, '[^0-9]', '', 'g') || '%' OR
       regexp_replace(c.cnpj, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($2, '[^0-9]', '', 'g') || '%')
  -- Filtros específicos
  AND ($3 = '' OR LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($3)) || '%')
  AND ($4 = '' OR LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($4)) || '%')
  AND ($5 = '' OR regexp_replace(c.cpf, '[^0-9]', '', 'g') = regexp_replace($5, '[^0-9]', '', 'g'))
  AND ($6 = '' OR regexp_replace(c.cnpj, '[^0-9]', '', 'g') = regexp_replace($6, '[^0-9]', '', 'g'))
  AND ($7 = '' OR LOWER(unaccent(c.cidade)) LIKE '%' || LOWER(unaccent($7)) || '%')
  AND ($8 = '' OR c.uf = $8)
  AND ($9 = '' OR c.tipo_pessoa = $9)
  AND ($10 = '' OR regexp_replace(c.telefone, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($10, '[^0-9]', '', 'g') || '%')
  AND ($11 = '' OR regexp_replace(c.celular, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($11, '[^0-9]', '', 'g') || '%')
`

type CountClientesPaginatedParams struct {
	TenantID uuid.UUID   `json:"tenant_id"`
	Column2  interface{} `json:"column_2"`
	Column3  interface{} `json:"column_3"`
	Column4  interface{} `json:"column_4"`
	Column5  interface{} `json:"column_5"`
	Column6  interface{} `json:"column_6"`
	Column7  interface{} `json:"column_7"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
	Column11 interface{} `json:"column_11"`
}

func (q *Queries) CountClientesPaginated(ctx context.Context, arg CountClientesPaginatedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countClientesPaginated,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countClientesSmartSearch = `-- name: CountClientesSmartSearch :one
SELECT COUNT(*)
FROM public.clientes c
WHERE c.tenant_id  = $1
  AND c.deleted_at IS NULL
  AND (
        $2 = ''
        OR LOWER(unaccent(c.nome_razao_social)) LIKE '%'||LOWER(unaccent($2))||'%'
        OR LOWER(unaccent(c.nome_fantasia))     LIKE '%'||LOWER(unaccent($2))||'%'
        OR (
             regexp_replace($2, '[^0-9]', '', 'g') <> ''
             AND (
                    regexp_replace(c.telefone, '[^0-9]', '', 'g')
                        LIKE '%'||regexp_replace($2, '[^0-9]', '', 'g')||'%'
                 OR regexp_replace(c.celular,  '[^0-9]', '', 'g')
                        LIKE '%'||regexp_replace($2, '[^0-9]', '', 'g')||'%'
                )
           )
      )
`

type CountClientesSmartSearchParams struct {
	TenantID uuid.UUID   `json:"tenant_id"`
	Column2  interface{} `json:"column_2"`
}

func (q *Queries) CountClientesSmartSearch(ctx context.Context, arg CountClientesSmartSearchParams) (int64, error) {
	row := q.db.QueryRow(ctx, countClientesSmartSearch, arg.TenantID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCliente = `-- name: CreateCliente :one

INSERT INTO public.clientes (
    tenant_id,
    tipo_pessoa,
    nome_razao_social,
    nome_fantasia,
    cpf,
    cnpj,
    rg,
    ie,
    im,
    data_nascimento,
    email,
    telefone,
    celular,
    cep,
    logradouro,
    numero,
    complemento,
    bairro,
    cidade,
    uf
) VALUES (
    $1,  $2,  $3,  $4,  $5,  $6,  $7,  $8,  $9, $10,
   $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
)
RETURNING
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at, deleted_at
`

type CreateClienteParams struct {
	TenantID        uuid.UUID   `json:"tenant_id"`
	TipoPessoa      string      `json:"tipo_pessoa"`
	NomeRazaoSocial string      `json:"nome_razao_social"`
	NomeFantasia    pgtype.Text `json:"nome_fantasia"`
	Cpf             pgtype.Text `json:"cpf"`
	Cnpj            pgtype.Text `json:"cnpj"`
	Rg              pgtype.Text `json:"rg"`
	Ie              pgtype.Text `json:"ie"`
	Im              pgtype.Text `json:"im"`
	DataNascimento  pgtype.Date `json:"data_nascimento"`
	Email           pgtype.Text `json:"email"`
	Telefone        pgtype.Text `json:"telefone"`
	Celular         pgtype.Text `json:"celular"`
	Cep             pgtype.Text `json:"cep"`
	Logradouro      pgtype.Text `json:"logradouro"`
	Numero          pgtype.Text `json:"numero"`
	Complemento     pgtype.Text `json:"complemento"`
	Bairro          pgtype.Text `json:"bairro"`
	Cidade          pgtype.Text `json:"cidade"`
	Uf              pgtype.Text `json:"uf"`
}

// ***********************
// CLIENTES
// ***********************
func (q *Queries) CreateCliente(ctx context.Context, arg CreateClienteParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, createCliente,
		arg.TenantID,
		arg.TipoPessoa,
		arg.NomeRazaoSocial,
		arg.NomeFantasia,
		arg.Cpf,
		arg.Cnpj,
		arg.Rg,
		arg.Ie,
		arg.Im,
		arg.DataNascimento,
		arg.Email,
		arg.Telefone,
		arg.Celular,
		arg.Cep,
		arg.Logradouro,
		arg.Numero,
		arg.Complemento,
		arg.Bairro,
		arg.Cidade,
		arg.Uf,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCliente = `-- name: DeleteCliente :exec
UPDATE public.clientes
SET deleted_at = now()
WHERE id = $1
  AND tenant_id = $2
  AND deleted_at IS NULL
`

type DeleteClienteParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCliente(ctx context.Context, arg DeleteClienteParams) error {
	_, err := q.db.Exec(ctx, deleteCliente, arg.ID, arg.TenantID)
	return err
}

const getCliente = `-- name: GetCliente :one
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at, deleted_at
FROM public.clientes
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetCliente(ctx context.Context, id uuid.UUID) (Cliente, error) {
	row := q.db.QueryRow(ctx, getCliente, id)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClienteByCNPJ = `-- name: GetClienteByCNPJ :one
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at, deleted_at
FROM public.clientes
WHERE cnpj = $1
  AND tenant_id = $2
  AND deleted_at IS NULL
`

type GetClienteByCNPJParams struct {
	Cnpj     pgtype.Text `json:"cnpj"`
	TenantID uuid.UUID   `json:"tenant_id"`
}

func (q *Queries) GetClienteByCNPJ(ctx context.Context, arg GetClienteByCNPJParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getClienteByCNPJ, arg.Cnpj, arg.TenantID)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClienteByCPF = `-- name: GetClienteByCPF :one
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at, deleted_at
FROM public.clientes
WHERE cpf = $1
  AND tenant_id = $2
  AND deleted_at IS NULL
`

type GetClienteByCPFParams struct {
	Cpf      pgtype.Text `json:"cpf"`
	TenantID uuid.UUID   `json:"tenant_id"`
}

func (q *Queries) GetClienteByCPF(ctx context.Context, arg GetClienteByCPFParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getClienteByCPF, arg.Cpf, arg.TenantID)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listClientesByTenant = `-- name: ListClientesByTenant :many
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at, deleted_at
FROM public.clientes
WHERE tenant_id = $1
  AND deleted_at IS NULL
ORDER BY nome_razao_social
LIMIT  $2 OFFSET $3
`

type ListClientesByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListClientesByTenant(ctx context.Context, arg ListClientesByTenantParams) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, listClientesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cliente
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TipoPessoa,
			&i.NomeRazaoSocial,
			&i.NomeFantasia,
			&i.Cpf,
			&i.Cnpj,
			&i.Rg,
			&i.Ie,
			&i.Im,
			&i.DataNascimento,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.Cep,
			&i.Logradouro,
			&i.Numero,
			&i.Complemento,
			&i.Bairro,
			&i.Cidade,
			&i.Uf,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientesPaginated = `-- name: ListClientesPaginated :many
SELECT
  c.id, c.tenant_id, c.tipo_pessoa, c.nome_razao_social, c.nome_fantasia, c.cpf, c.cnpj, c.rg, c.ie, c.im, c.data_nascimento, c.email, c.telefone, c.celular, c.cep, c.logradouro, c.numero, c.complemento, c.bairro, c.cidade, c.uf, c.created_at, c.updated_at, c.deleted_at
FROM public.clientes c
WHERE c.tenant_id = $1
  AND c.deleted_at IS NULL
  -- Filtro geral (pesquisa em nome/razão social, nome fantasia, cpf, cnpj)
  AND ($5 = '' OR 
       LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($5)) || '%' OR 
       LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($5)) || '%' OR
       regexp_replace(c.cpf, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($5, '[^0-9]', '', 'g') || '%' OR
       regexp_replace(c.cnpj, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($5, '[^0-9]', '', 'g') || '%')
  -- Filtros específicos
  AND ($6 = '' OR LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($6)) || '%')
  AND ($7 = '' OR LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($7)) || '%')
  AND ($8 = '' OR regexp_replace(c.cpf, '[^0-9]', '', 'g') = regexp_replace($8, '[^0-9]', '', 'g'))
  AND ($9 = '' OR regexp_replace(c.cnpj, '[^0-9]', '', 'g') = regexp_replace($9, '[^0-9]', '', 'g'))
  AND ($10 = '' OR LOWER(unaccent(c.cidade)) LIKE '%' || LOWER(unaccent($10)) || '%')
  AND ($11 = '' OR c.uf = $11)
  AND ($12 = '' OR c.tipo_pessoa = $12)
  AND ($13 = '' OR regexp_replace(c.telefone, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($13, '[^0-9]', '', 'g') || '%')
  AND ($14 = '' OR regexp_replace(c.celular, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($14, '[^0-9]', '', 'g') || '%')
ORDER BY 
  CASE WHEN $3 = 'nome' AND $4 = 'asc' THEN c.nome_razao_social END ASC,
  CASE WHEN $3 = 'nome' AND $4 = 'desc' THEN c.nome_razao_social END DESC,
  CASE WHEN $3 = 'fantasia' AND $4 = 'asc' THEN c.nome_fantasia END ASC,
  CASE WHEN $3 = 'fantasia' AND $4 = 'desc' THEN c.nome_fantasia END DESC,
  CASE WHEN $3 = 'cidade' AND $4 = 'asc' THEN c.cidade END ASC,
  CASE WHEN $3 = 'cidade' AND $4 = 'desc' THEN c.cidade END DESC,
  CASE WHEN $3 = 'data_cadastro' AND $4 = 'asc' THEN c.created_at END ASC,
  CASE WHEN $3 = 'data_cadastro' AND $4 = 'desc' THEN c.created_at END DESC,
  CASE WHEN $3 = 'ultima_atualizacao' AND $4 = 'asc' THEN c.updated_at END ASC,
  CASE WHEN $3 = 'ultima_atualizacao' AND $4 = 'desc' THEN c.updated_at END DESC,
  CASE WHEN $3 = '' THEN c.nome_razao_social END ASC
LIMIT $2 OFFSET $15
`

type ListClientesPaginatedParams struct {
	TenantID uuid.UUID   `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Column3  interface{} `json:"column_3"`
	Column4  interface{} `json:"column_4"`
	Column5  interface{} `json:"column_5"`
	Column6  interface{} `json:"column_6"`
	Column7  interface{} `json:"column_7"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
	Column11 interface{} `json:"column_11"`
	Column12 interface{} `json:"column_12"`
	Column13 interface{} `json:"column_13"`
	Column14 interface{} `json:"column_14"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListClientesPaginated(ctx context.Context, arg ListClientesPaginatedParams) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, listClientesPaginated,
		arg.TenantID,
		arg.Limit,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Column12,
		arg.Column13,
		arg.Column14,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cliente
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TipoPessoa,
			&i.NomeRazaoSocial,
			&i.NomeFantasia,
			&i.Cpf,
			&i.Cnpj,
			&i.Rg,
			&i.Ie,
			&i.Im,
			&i.DataNascimento,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.Cep,
			&i.Logradouro,
			&i.Numero,
			&i.Complemento,
			&i.Bairro,
			&i.Cidade,
			&i.Uf,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientesSmartSearch = `-- name: ListClientesSmartSearch :many
SELECT
    c.id, c.tenant_id, c.tipo_pessoa, c.nome_razao_social, c.nome_fantasia, c.cpf, c.cnpj, c.rg, c.ie, c.im, c.data_nascimento, c.email, c.telefone, c.celular, c.cep, c.logradouro, c.numero, c.complemento, c.bairro, c.cidade, c.uf, c.created_at, c.updated_at, c.deleted_at,

    /* ────────── Ranking de relevância ────────── */
    CASE
        WHEN $3 = '' THEN 0                                                 /* pesquisa vazia → sem score            */
        WHEN LOWER(unaccent(c.nome_razao_social)) LIKE '%'||LOWER(unaccent($3))||'%'   THEN 3
        WHEN LOWER(unaccent(c.nome_fantasia))     LIKE '%'||LOWER(unaccent($3))||'%'   THEN 2
        /* telefones só contam se o termo tiver dígitos                         */
        WHEN regexp_replace($3, '[^0-9]', '', 'g') <> ''
             AND regexp_replace(c.telefone, '[^0-9]', '', 'g')
                 LIKE '%'||regexp_replace($3, '[^0-9]', '', 'g')||'%'                 THEN 1
        WHEN regexp_replace($3, '[^0-9]', '', 'g') <> ''
             AND regexp_replace(c.celular,  '[^0-9]', '', 'g')
                 LIKE '%'||regexp_replace($3, '[^0-9]', '', 'g')||'%'                 THEN 1
        ELSE 0
    END AS relevance_score

FROM public.clientes c
WHERE c.tenant_id  = $1
  AND c.deleted_at IS NULL
  AND (
        /* pesquisa vazia devolve todos                                          */
        $3 = ''
        OR LOWER(unaccent(c.nome_razao_social)) LIKE '%'||LOWER(unaccent($3))||'%'
        OR LOWER(unaccent(c.nome_fantasia))     LIKE '%'||LOWER(unaccent($3))||'%'
        /* telefones/celulares somente se houver dígitos no termo                */
        OR (
             regexp_replace($3, '[^0-9]', '', 'g') <> ''
             AND (
                    regexp_replace(c.telefone, '[^0-9]', '', 'g')
                        LIKE '%'||regexp_replace($3, '[^0-9]', '', 'g')||'%'
                 OR regexp_replace(c.celular,  '[^0-9]', '', 'g')
                        LIKE '%'||regexp_replace($3, '[^0-9]', '', 'g')||'%'
                )
           )
      )
ORDER BY
    relevance_score DESC,
    c.nome_razao_social ASC
LIMIT  $2
OFFSET $4
`

type ListClientesSmartSearchParams struct {
	TenantID uuid.UUID   `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Column3  interface{} `json:"column_3"`
	Offset   int32       `json:"offset"`
}

type ListClientesSmartSearchRow struct {
	ID              uuid.UUID          `json:"id"`
	TenantID        uuid.UUID          `json:"tenant_id"`
	TipoPessoa      string             `json:"tipo_pessoa"`
	NomeRazaoSocial string             `json:"nome_razao_social"`
	NomeFantasia    pgtype.Text        `json:"nome_fantasia"`
	Cpf             pgtype.Text        `json:"cpf"`
	Cnpj            pgtype.Text        `json:"cnpj"`
	Rg              pgtype.Text        `json:"rg"`
	Ie              pgtype.Text        `json:"ie"`
	Im              pgtype.Text        `json:"im"`
	DataNascimento  pgtype.Date        `json:"data_nascimento"`
	Email           pgtype.Text        `json:"email"`
	Telefone        pgtype.Text        `json:"telefone"`
	Celular         pgtype.Text        `json:"celular"`
	Cep             pgtype.Text        `json:"cep"`
	Logradouro      pgtype.Text        `json:"logradouro"`
	Numero          pgtype.Text        `json:"numero"`
	Complemento     pgtype.Text        `json:"complemento"`
	Bairro          pgtype.Text        `json:"bairro"`
	Cidade          pgtype.Text        `json:"cidade"`
	Uf              pgtype.Text        `json:"uf"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	RelevanceScore  int32              `json:"relevance_score"`
}

func (q *Queries) ListClientesSmartSearch(ctx context.Context, arg ListClientesSmartSearchParams) ([]ListClientesSmartSearchRow, error) {
	rows, err := q.db.Query(ctx, listClientesSmartSearch,
		arg.TenantID,
		arg.Limit,
		arg.Column3,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientesSmartSearchRow
	for rows.Next() {
		var i ListClientesSmartSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TipoPessoa,
			&i.NomeRazaoSocial,
			&i.NomeFantasia,
			&i.Cpf,
			&i.Cnpj,
			&i.Rg,
			&i.Ie,
			&i.Im,
			&i.DataNascimento,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.Cep,
			&i.Logradouro,
			&i.Numero,
			&i.Complemento,
			&i.Bairro,
			&i.Cidade,
			&i.Uf,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.RelevanceScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientesSmartSearchFuzzy = `-- name: ListClientesSmartSearchFuzzy :many
SELECT
    c.id, c.tenant_id, c.tipo_pessoa, c.nome_razao_social, c.nome_fantasia, c.cpf, c.cnpj, c.rg, c.ie, c.im, c.data_nascimento, c.email, c.telefone, c.celular, c.cep, c.logradouro, c.numero, c.complemento, c.bairro, c.cidade, c.uf, c.created_at, c.updated_at, c.deleted_at,
    -- Score de relevância mais sofisticado
    CASE
        WHEN $3 = '' THEN 0
        -- Match exato no início do nome tem score maior
        WHEN LOWER(unaccent(c.nome_razao_social)) LIKE LOWER(unaccent($3)) || '%' THEN 5
        WHEN LOWER(unaccent(c.nome_fantasia)) LIKE LOWER(unaccent($3)) || '%' THEN 4
        -- Match parcial no nome
        WHEN LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($3)) || '%' THEN 3
        WHEN LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($3)) || '%' THEN 2
        -- Match em telefones
        WHEN regexp_replace(c.telefone, '[^0-9]', '', 'g') LIKE regexp_replace($3, '[^0-9]', '', 'g') || '%' THEN 2
        WHEN regexp_replace(c.celular, '[^0-9]', '', 'g') LIKE regexp_replace($3, '[^0-9]', '', 'g') || '%' THEN 2
        WHEN regexp_replace(c.telefone, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($3, '[^0-9]', '', 'g') || '%' THEN 1
        WHEN regexp_replace(c.celular, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($3, '[^0-9]', '', 'g') || '%' THEN 1
        ELSE 0
        END as relevance_score
FROM public.clientes c
WHERE c.tenant_id = $1
  AND c.deleted_at IS NULL
  AND (
    $3 = '' OR
        -- Busca em nomes (com e sem acentos)
    LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($3)) || '%' OR
    LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($3)) || '%' OR
        -- Busca em telefones (flexível - aceita com ou sem formatação)
    regexp_replace(c.telefone, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($3, '[^0-9]', '', 'g') || '%' OR
    regexp_replace(c.celular, '[^0-9]', '', 'g') LIKE '%' || regexp_replace($3, '[^0-9]', '', 'g') || '%' OR
        -- Busca adicional: telefone formatado
    c.telefone LIKE '%' || $3 || '%' OR
    c.celular LIKE '%' || $3 || '%'
    )
ORDER BY
    relevance_score DESC,
    c.nome_razao_social ASC
    LIMIT $2 OFFSET $4
`

type ListClientesSmartSearchFuzzyParams struct {
	TenantID uuid.UUID   `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Column3  interface{} `json:"column_3"`
	Offset   int32       `json:"offset"`
}

type ListClientesSmartSearchFuzzyRow struct {
	ID              uuid.UUID          `json:"id"`
	TenantID        uuid.UUID          `json:"tenant_id"`
	TipoPessoa      string             `json:"tipo_pessoa"`
	NomeRazaoSocial string             `json:"nome_razao_social"`
	NomeFantasia    pgtype.Text        `json:"nome_fantasia"`
	Cpf             pgtype.Text        `json:"cpf"`
	Cnpj            pgtype.Text        `json:"cnpj"`
	Rg              pgtype.Text        `json:"rg"`
	Ie              pgtype.Text        `json:"ie"`
	Im              pgtype.Text        `json:"im"`
	DataNascimento  pgtype.Date        `json:"data_nascimento"`
	Email           pgtype.Text        `json:"email"`
	Telefone        pgtype.Text        `json:"telefone"`
	Celular         pgtype.Text        `json:"celular"`
	Cep             pgtype.Text        `json:"cep"`
	Logradouro      pgtype.Text        `json:"logradouro"`
	Numero          pgtype.Text        `json:"numero"`
	Complemento     pgtype.Text        `json:"complemento"`
	Bairro          pgtype.Text        `json:"bairro"`
	Cidade          pgtype.Text        `json:"cidade"`
	Uf              pgtype.Text        `json:"uf"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	RelevanceScore  int32              `json:"relevance_score"`
}

func (q *Queries) ListClientesSmartSearchFuzzy(ctx context.Context, arg ListClientesSmartSearchFuzzyParams) ([]ListClientesSmartSearchFuzzyRow, error) {
	rows, err := q.db.Query(ctx, listClientesSmartSearchFuzzy,
		arg.TenantID,
		arg.Limit,
		arg.Column3,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientesSmartSearchFuzzyRow
	for rows.Next() {
		var i ListClientesSmartSearchFuzzyRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TipoPessoa,
			&i.NomeRazaoSocial,
			&i.NomeFantasia,
			&i.Cpf,
			&i.Cnpj,
			&i.Rg,
			&i.Ie,
			&i.Im,
			&i.DataNascimento,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.Cep,
			&i.Logradouro,
			&i.Numero,
			&i.Complemento,
			&i.Bairro,
			&i.Cidade,
			&i.Uf,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.RelevanceScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCliente = `-- name: UpdateCliente :one
UPDATE public.clientes
SET
    tipo_pessoa        = $3,
    nome_razao_social  = $4,
    nome_fantasia      = $5,
    cpf                = $6,
    cnpj               = $7,
    rg                 = $8,
    ie                 = $9,
    im                 = $10,
    data_nascimento    = $11,
    email              = $12,
    telefone           = $13,
    celular            = $14,
    cep                = $15,
    logradouro         = $16,
    numero             = $17,
    complemento        = $18,
    bairro             = $19,
    cidade             = $20,
    uf                 = $21,
    updated_at         = now()
WHERE id        = $1   -- id do cliente
  AND tenant_id = $2   -- segurança multitenant
  AND deleted_at IS NULL
RETURNING
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at, deleted_at
`

type UpdateClienteParams struct {
	ID              uuid.UUID   `json:"id"`
	TenantID        uuid.UUID   `json:"tenant_id"`
	TipoPessoa      string      `json:"tipo_pessoa"`
	NomeRazaoSocial string      `json:"nome_razao_social"`
	NomeFantasia    pgtype.Text `json:"nome_fantasia"`
	Cpf             pgtype.Text `json:"cpf"`
	Cnpj            pgtype.Text `json:"cnpj"`
	Rg              pgtype.Text `json:"rg"`
	Ie              pgtype.Text `json:"ie"`
	Im              pgtype.Text `json:"im"`
	DataNascimento  pgtype.Date `json:"data_nascimento"`
	Email           pgtype.Text `json:"email"`
	Telefone        pgtype.Text `json:"telefone"`
	Celular         pgtype.Text `json:"celular"`
	Cep             pgtype.Text `json:"cep"`
	Logradouro      pgtype.Text `json:"logradouro"`
	Numero          pgtype.Text `json:"numero"`
	Complemento     pgtype.Text `json:"complemento"`
	Bairro          pgtype.Text `json:"bairro"`
	Cidade          pgtype.Text `json:"cidade"`
	Uf              pgtype.Text `json:"uf"`
}

func (q *Queries) UpdateCliente(ctx context.Context, arg UpdateClienteParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, updateCliente,
		arg.ID,
		arg.TenantID,
		arg.TipoPessoa,
		arg.NomeRazaoSocial,
		arg.NomeFantasia,
		arg.Cpf,
		arg.Cnpj,
		arg.Rg,
		arg.Ie,
		arg.Im,
		arg.DataNascimento,
		arg.Email,
		arg.Telefone,
		arg.Celular,
		arg.Cep,
		arg.Logradouro,
		arg.Numero,
		arg.Complemento,
		arg.Bairro,
		arg.Cidade,
		arg.Uf,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const upsertCliente = `-- name: UpsertCliente :one
INSERT INTO public.clientes (
    id,
    tenant_id,
    nome_razao_social,
    celular,
    logradouro,
    numero,
    complemento,
    bairro,
    tipo_pessoa
)
VALUES (
    COALESCE($1, gen_random_uuid()),
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
ON CONFLICT (id) DO UPDATE
SET
    nome_razao_social = $3,
    celular = $4,
    logradouro = $5,
    numero = $6,
    complemento = $7,
    bairro = $8,
    tipo_pessoa = $9,
    updated_at = now()
WHERE clientes.tenant_id = $2
  AND clientes.deleted_at IS NULL
RETURNING id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at, deleted_at
`

type UpsertClienteParams struct {
	Column1         interface{} `json:"column_1"`
	TenantID        uuid.UUID   `json:"tenant_id"`
	NomeRazaoSocial string      `json:"nome_razao_social"`
	Celular         pgtype.Text `json:"celular"`
	Logradouro      pgtype.Text `json:"logradouro"`
	Numero          pgtype.Text `json:"numero"`
	Complemento     pgtype.Text `json:"complemento"`
	Bairro          pgtype.Text `json:"bairro"`
	TipoPessoa      string      `json:"tipo_pessoa"`
}

func (q *Queries) UpsertCliente(ctx context.Context, arg UpsertClienteParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, upsertCliente,
		arg.Column1,
		arg.TenantID,
		arg.NomeRazaoSocial,
		arg.Celular,
		arg.Logradouro,
		arg.Numero,
		arg.Complemento,
		arg.Bairro,
		arg.TipoPessoa,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
