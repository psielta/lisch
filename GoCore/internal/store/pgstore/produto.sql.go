// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: produto.sql

package pgstore

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProdutosByCategoria = `-- name: CountProdutosByCategoria :one
SELECT COUNT(*)
FROM produtos
WHERE id_categoria = $1 AND deleted_at IS NULL
`

func (q *Queries) CountProdutosByCategoria(ctx context.Context, idCategoria uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProdutosByCategoria, idCategoria)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduto = `-- name: CreateProduto :one


INSERT INTO produtos (
    id_categoria,
    nome,
    descricao,
    codigo_externo,
    sku,
    permite_observacao,
    ordem,
    imagem_url,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, seq_id, id_categoria, nome, descricao, codigo_externo, sku, permite_observacao, ordem, imagem_url, status, created_at, updated_at
`

type CreateProdutoParams struct {
	IDCategoria       uuid.UUID   `json:"id_categoria"`
	Nome              string      `json:"nome"`
	Descricao         pgtype.Text `json:"descricao"`
	CodigoExterno     pgtype.Text `json:"codigo_externo"`
	Sku               pgtype.Text `json:"sku"`
	PermiteObservacao pgtype.Bool `json:"permite_observacao"`
	Ordem             pgtype.Int4 `json:"ordem"`
	ImagemUrl         pgtype.Text `json:"imagem_url"`
	Status            int16       `json:"status"`
}

type CreateProdutoRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// SQLC Queries para Produtos
// ***********************
// PRODUTOS
// ***********************
func (q *Queries) CreateProduto(ctx context.Context, arg CreateProdutoParams) (CreateProdutoRow, error) {
	row := q.db.QueryRow(ctx, createProduto,
		arg.IDCategoria,
		arg.Nome,
		arg.Descricao,
		arg.CodigoExterno,
		arg.Sku,
		arg.PermiteObservacao,
		arg.Ordem,
		arg.ImagemUrl,
		arg.Status,
	)
	var i CreateProdutoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProduto = `-- name: GetProduto :one
SELECT
    p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku,
    p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at,
    c.id_tenant -- Incluindo id_tenant da categoria para referência
FROM produtos p
JOIN categorias c ON p.id_categoria = c.id
WHERE p.id = $1 AND p.deleted_at IS NULL
`

type GetProdutoRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
}

func (q *Queries) GetProduto(ctx context.Context, id uuid.UUID) (GetProdutoRow, error) {
	row := q.db.QueryRow(ctx, getProduto, id)
	var i GetProdutoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IDTenant,
	)
	return i, err
}

const getProdutoByCodigoExternoAndTenant = `-- name: GetProdutoByCodigoExternoAndTenant :one
SELECT
    p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku,
    p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at,
    c.id_tenant
FROM produtos p
JOIN categorias c ON p.id_categoria = c.id
WHERE p.codigo_externo = $1 AND c.id_tenant = $2 AND p.deleted_at IS NULL
`

type GetProdutoByCodigoExternoAndTenantParams struct {
	CodigoExterno pgtype.Text `json:"codigo_externo"`
	IDTenant      uuid.UUID   `json:"id_tenant"`
}

type GetProdutoByCodigoExternoAndTenantRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
}

func (q *Queries) GetProdutoByCodigoExternoAndTenant(ctx context.Context, arg GetProdutoByCodigoExternoAndTenantParams) (GetProdutoByCodigoExternoAndTenantRow, error) {
	row := q.db.QueryRow(ctx, getProdutoByCodigoExternoAndTenant, arg.CodigoExterno, arg.IDTenant)
	var i GetProdutoByCodigoExternoAndTenantRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IDTenant,
	)
	return i, err
}

const getProdutoBySeqID = `-- name: GetProdutoBySeqID :one
SELECT
    p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku,
    p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at,
    c.id_tenant
FROM produtos p
JOIN categorias c ON p.id_categoria = c.id
WHERE p.seq_id = $1 AND p.deleted_at IS NULL
`

type GetProdutoBySeqIDRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
}

func (q *Queries) GetProdutoBySeqID(ctx context.Context, seqID pgtype.Int8) (GetProdutoBySeqIDRow, error) {
	row := q.db.QueryRow(ctx, getProdutoBySeqID, seqID)
	var i GetProdutoBySeqIDRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IDTenant,
	)
	return i, err
}

const hardDeleteProduto = `-- name: HardDeleteProduto :exec
DELETE FROM produtos p
USING categorias c
WHERE p.id_categoria = c.id
  AND p.id = $1
  AND c.id_tenant = $2
`

type HardDeleteProdutoParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

func (q *Queries) HardDeleteProduto(ctx context.Context, arg HardDeleteProdutoParams) error {
	_, err := q.db.Exec(ctx, hardDeleteProduto, arg.ID, arg.IDTenant)
	return err
}

const listProdutosByCategoria = `-- name: ListProdutosByCategoria :many
SELECT
    p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku,
    p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at
FROM produtos p
WHERE p.id_categoria = $1 AND p.deleted_at IS NULL
ORDER BY p.ordem NULLS LAST, p.nome
LIMIT $2 OFFSET $3
`

type ListProdutosByCategoriaParams struct {
	IDCategoria uuid.UUID `json:"id_categoria"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListProdutosByCategoriaRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListProdutosByCategoria(ctx context.Context, arg ListProdutosByCategoriaParams) ([]ListProdutosByCategoriaRow, error) {
	rows, err := q.db.Query(ctx, listProdutosByCategoria, arg.IDCategoria, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProdutosByCategoriaRow
	for rows.Next() {
		var i ListProdutosByCategoriaRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.IDCategoria,
			&i.Nome,
			&i.Descricao,
			&i.CodigoExterno,
			&i.Sku,
			&i.PermiteObservacao,
			&i.Ordem,
			&i.ImagemUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProdutosByTenant = `-- name: ListProdutosByTenant :many
SELECT
    p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku,
    p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at,
    c.id_tenant
FROM produtos p
JOIN categorias c ON p.id_categoria = c.id
WHERE c.id_tenant = $1 AND p.deleted_at IS NULL
ORDER BY c.ordem NULLS LAST, c.nome, p.ordem NULLS LAST, p.nome
LIMIT $2 OFFSET $3
`

type ListProdutosByTenantParams struct {
	IDTenant uuid.UUID `json:"id_tenant"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListProdutosByTenantRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	IDTenant          uuid.UUID          `json:"id_tenant"`
}

func (q *Queries) ListProdutosByTenant(ctx context.Context, arg ListProdutosByTenantParams) ([]ListProdutosByTenantRow, error) {
	rows, err := q.db.Query(ctx, listProdutosByTenant, arg.IDTenant, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProdutosByTenantRow
	for rows.Next() {
		var i ListProdutosByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.SeqID,
			&i.IDCategoria,
			&i.Nome,
			&i.Descricao,
			&i.CodigoExterno,
			&i.Sku,
			&i.PermiteObservacao,
			&i.Ordem,
			&i.ImagemUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IDTenant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreProduto = `-- name: RestoreProduto :one
UPDATE produtos p
SET deleted_at = NULL,
    updated_at = now()
FROM categorias c
WHERE p.id_categoria = c.id
  AND p.id = $1
  AND c.id_tenant = $2
  AND p.deleted_at IS NOT NULL
RETURNING p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku, p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at
`

type RestoreProdutoParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

type RestoreProdutoRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) RestoreProduto(ctx context.Context, arg RestoreProdutoParams) (RestoreProdutoRow, error) {
	row := q.db.QueryRow(ctx, restoreProduto, arg.ID, arg.IDTenant)
	var i RestoreProdutoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const softDeleteProduto = `-- name: SoftDeleteProduto :exec
UPDATE produtos p
SET deleted_at = now()
FROM categorias c
WHERE p.id_categoria = c.id
  AND p.id = $1
  AND c.id_tenant = $2
  AND p.deleted_at IS NULL
`

type SoftDeleteProdutoParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
}

func (q *Queries) SoftDeleteProduto(ctx context.Context, arg SoftDeleteProdutoParams) error {
	_, err := q.db.Exec(ctx, softDeleteProduto, arg.ID, arg.IDTenant)
	return err
}

const updateProduto = `-- name: UpdateProduto :one
UPDATE produtos p
SET
    id_categoria = $3,
    nome = $4,
    descricao = $5,
    codigo_externo = $6,
    sku = $7,
    permite_observacao = $8,
    ordem = $9,
    imagem_url = $10,
    status = $11,
    updated_at = now()
FROM categorias c
WHERE p.id_categoria = c.id
  AND p.id = $1
  AND c.id_tenant = $2
  AND p.deleted_at IS NULL
RETURNING p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku, p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at
`

type UpdateProdutoParams struct {
	ID                uuid.UUID   `json:"id"`
	IDTenant          uuid.UUID   `json:"id_tenant"`
	IDCategoria       uuid.UUID   `json:"id_categoria"`
	Nome              string      `json:"nome"`
	Descricao         pgtype.Text `json:"descricao"`
	CodigoExterno     pgtype.Text `json:"codigo_externo"`
	Sku               pgtype.Text `json:"sku"`
	PermiteObservacao pgtype.Bool `json:"permite_observacao"`
	Ordem             pgtype.Int4 `json:"ordem"`
	ImagemUrl         pgtype.Text `json:"imagem_url"`
	Status            int16       `json:"status"`
}

type UpdateProdutoRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateProduto(ctx context.Context, arg UpdateProdutoParams) (UpdateProdutoRow, error) {
	row := q.db.QueryRow(ctx, updateProduto,
		arg.ID,
		arg.IDTenant,
		arg.IDCategoria,
		arg.Nome,
		arg.Descricao,
		arg.CodigoExterno,
		arg.Sku,
		arg.PermiteObservacao,
		arg.Ordem,
		arg.ImagemUrl,
		arg.Status,
	)
	var i UpdateProdutoRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProdutoOrdem = `-- name: UpdateProdutoOrdem :one
UPDATE produtos p
SET
    ordem = $3,
    updated_at = now()
FROM categorias c
WHERE p.id_categoria = c.id
  AND p.id = $1
  AND c.id_tenant = $2
  AND p.deleted_at IS NULL
RETURNING p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku, p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at
`

type UpdateProdutoOrdemParams struct {
	ID       uuid.UUID   `json:"id"`
	IDTenant uuid.UUID   `json:"id_tenant"`
	Ordem    pgtype.Int4 `json:"ordem"`
}

type UpdateProdutoOrdemRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateProdutoOrdem(ctx context.Context, arg UpdateProdutoOrdemParams) (UpdateProdutoOrdemRow, error) {
	row := q.db.QueryRow(ctx, updateProdutoOrdem, arg.ID, arg.IDTenant, arg.Ordem)
	var i UpdateProdutoOrdemRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProdutoStatus = `-- name: UpdateProdutoStatus :one

UPDATE produtos p
SET
    status = $3,
    updated_at = now()
FROM categorias c
WHERE p.id_categoria = c.id
  AND p.id = $1
  AND c.id_tenant = $2
  AND p.deleted_at IS NULL
RETURNING p.id, p.seq_id, p.id_categoria, p.nome, p.descricao, p.codigo_externo, p.sku, p.permite_observacao, p.ordem, p.imagem_url, p.status, p.created_at, p.updated_at
`

type UpdateProdutoStatusParams struct {
	ID       uuid.UUID `json:"id"`
	IDTenant uuid.UUID `json:"id_tenant"`
	Status   int16     `json:"status"`
}

type UpdateProdutoStatusRow struct {
	ID                uuid.UUID          `json:"id"`
	SeqID             pgtype.Int8        `json:"seq_id"`
	IDCategoria       uuid.UUID          `json:"id_categoria"`
	Nome              string             `json:"nome"`
	Descricao         pgtype.Text        `json:"descricao"`
	CodigoExterno     pgtype.Text        `json:"codigo_externo"`
	Sku               pgtype.Text        `json:"sku"`
	PermiteObservacao pgtype.Bool        `json:"permite_observacao"`
	Ordem             pgtype.Int4        `json:"ordem"`
	ImagemUrl         pgtype.Text        `json:"imagem_url"`
	Status            int16              `json:"status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// CUIDADO: Hard delete remove permanentemente. Certifique-se que as FKs em produto_precos estão ON DELETE CASCADE.
func (q *Queries) UpdateProdutoStatus(ctx context.Context, arg UpdateProdutoStatusParams) (UpdateProdutoStatusRow, error) {
	row := q.db.QueryRow(ctx, updateProdutoStatus, arg.ID, arg.IDTenant, arg.Status)
	var i UpdateProdutoStatusRow
	err := row.Scan(
		&i.ID,
		&i.SeqID,
		&i.IDCategoria,
		&i.Nome,
		&i.Descricao,
		&i.CodigoExterno,
		&i.Sku,
		&i.PermiteObservacao,
		&i.Ordem,
		&i.ImagemUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
