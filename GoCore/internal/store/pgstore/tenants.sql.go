// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tenants.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one

INSERT INTO products (seller_id, product_name, description, baseprice, auction_end, tenant_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, seller_id, product_name, description, baseprice, auction_end, is_sold, created_at, updated_at, tenant_id
`

type CreateProductParams struct {
	SellerID    uuid.UUID `json:"seller_id"`
	ProductName string    `json:"product_name"`
	Description string    `json:"description"`
	Baseprice   float64   `json:"baseprice"`
	AuctionEnd  time.Time `json:"auction_end"`
	TenantID    uuid.UUID `json:"tenant_id"`
}

// ***********************
// PRODUCTS
// ***********************
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.SellerID,
		arg.ProductName,
		arg.Description,
		arg.Baseprice,
		arg.AuctionEnd,
		arg.TenantID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.SellerID,
		&i.ProductName,
		&i.Description,
		&i.Baseprice,
		&i.AuctionEnd,
		&i.IsSold,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const createTenant = `-- name: CreateTenant :one


INSERT INTO tenants (name, plan, status)
VALUES ($1, $2, $3)
RETURNING id, name, plan, status, created_at
`

type CreateTenantParams struct {
	Name   string `json:"name"`
	Plan   string `json:"plan"`
	Status string `json:"status"`
}

// SQLC Queries for Multi-Tenant SaaS
// ***********************
// TENANTS
// ***********************
func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant, arg.Name, arg.Plan, arg.Status)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Plan,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (user_name, email, password_hash, bio, tenant_id, admin, permission_users, permission_categoria, permission_produto, permission_adicional, permission_cliente)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, user_name, email, bio, created_at, updated_at, tenant_id
`

type CreateUserParams struct {
	UserName            string      `json:"user_name"`
	Email               string      `json:"email"`
	PasswordHash        []byte      `json:"password_hash"`
	Bio                 string      `json:"bio"`
	TenantID            uuid.UUID   `json:"tenant_id"`
	Admin               int32       `json:"admin"`
	PermissionUsers     int32       `json:"permission_users"`
	PermissionCategoria pgtype.Int4 `json:"permission_categoria"`
	PermissionProduto   pgtype.Int4 `json:"permission_produto"`
	PermissionAdicional pgtype.Int4 `json:"permission_adicional"`
	PermissionCliente   pgtype.Int4 `json:"permission_cliente"`
}

type CreateUserRow struct {
	ID        uuid.UUID `json:"id"`
	UserName  string    `json:"user_name"`
	Email     string    `json:"email"`
	Bio       string    `json:"bio"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

// ***********************
// USERS
// ***********************
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserName,
		arg.Email,
		arg.PasswordHash,
		arg.Bio,
		arg.TenantID,
		arg.Admin,
		arg.PermissionUsers,
		arg.PermissionCategoria,
		arg.PermissionProduto,
		arg.PermissionAdicional,
		arg.PermissionCliente,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteTenant = `-- name: DeleteTenant :exec
DELETE FROM tenants
WHERE id = $1
`

func (q *Queries) DeleteTenant(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTenant, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, seller_id, product_name, description, baseprice, auction_end, is_sold, created_at, updated_at, tenant_id
FROM products
WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.SellerID,
		&i.ProductName,
		&i.Description,
		&i.Baseprice,
		&i.AuctionEnd,
		&i.IsSold,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const getTenant = `-- name: GetTenant :one
SELECT id, name, plan, status, created_at
FROM tenants
WHERE id = $1
`

func (q *Queries) GetTenant(ctx context.Context, id uuid.UUID) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenant, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Plan,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, user_name, email, password_hash, bio, created_at, updated_at, tenant_id, admin, permission_users, permission_categoria, permission_produto, permission_adicional, permission_cliente
FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.PasswordHash,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Admin,
		&i.PermissionUsers,
		&i.PermissionCategoria,
		&i.PermissionProduto,
		&i.PermissionAdicional,
		&i.PermissionCliente,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, user_name, email, bio, created_at, updated_at, tenant_id, admin, permission_users, permission_categoria, permission_produto, permission_adicional, permission_cliente
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID                  uuid.UUID   `json:"id"`
	UserName            string      `json:"user_name"`
	Email               string      `json:"email"`
	Bio                 string      `json:"bio"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	TenantID            uuid.UUID   `json:"tenant_id"`
	Admin               int32       `json:"admin"`
	PermissionUsers     int32       `json:"permission_users"`
	PermissionCategoria pgtype.Int4 `json:"permission_categoria"`
	PermissionProduto   pgtype.Int4 `json:"permission_produto"`
	PermissionAdicional pgtype.Int4 `json:"permission_adicional"`
	PermissionCliente   pgtype.Int4 `json:"permission_cliente"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Admin,
		&i.PermissionUsers,
		&i.PermissionCategoria,
		&i.PermissionProduto,
		&i.PermissionAdicional,
		&i.PermissionCliente,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT id, seller_id, product_name, description, baseprice, auction_end, is_sold, created_at, updated_at, tenant_id
FROM products
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.SellerID,
			&i.ProductName,
			&i.Description,
			&i.Baseprice,
			&i.AuctionEnd,
			&i.IsSold,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenants = `-- name: ListTenants :many
SELECT id, name, plan, status, created_at
FROM tenants
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListTenantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTenants(ctx context.Context, arg ListTenantsParams) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listTenants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tenant
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Plan,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, user_name, email, bio, created_at, updated_at, tenant_id, admin, permission_users, permission_categoria, permission_produto, permission_adicional, permission_cliente
FROM users
WHERE tenant_id = $1
ORDER BY email
`

type ListUsersRow struct {
	ID                  uuid.UUID   `json:"id"`
	UserName            string      `json:"user_name"`
	Email               string      `json:"email"`
	Bio                 string      `json:"bio"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	TenantID            uuid.UUID   `json:"tenant_id"`
	Admin               int32       `json:"admin"`
	PermissionUsers     int32       `json:"permission_users"`
	PermissionCategoria pgtype.Int4 `json:"permission_categoria"`
	PermissionProduto   pgtype.Int4 `json:"permission_produto"`
	PermissionAdicional pgtype.Int4 `json:"permission_adicional"`
	PermissionCliente   pgtype.Int4 `json:"permission_cliente"`
}

func (q *Queries) ListUsers(ctx context.Context, tenantID uuid.UUID) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.Email,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.Admin,
			&i.PermissionUsers,
			&i.PermissionCategoria,
			&i.PermissionProduto,
			&i.PermissionAdicional,
			&i.PermissionCliente,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET product_name = $2,
    description = $3,
    baseprice = $4,
    auction_end = $5,
    is_sold = $6,
    updated_at = now()
WHERE id = $1
RETURNING id, seller_id, product_name, description, baseprice, auction_end, is_sold, created_at, updated_at, tenant_id
`

type UpdateProductParams struct {
	ID          uuid.UUID `json:"id"`
	ProductName string    `json:"product_name"`
	Description string    `json:"description"`
	Baseprice   float64   `json:"baseprice"`
	AuctionEnd  time.Time `json:"auction_end"`
	IsSold      bool      `json:"is_sold"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.ProductName,
		arg.Description,
		arg.Baseprice,
		arg.AuctionEnd,
		arg.IsSold,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.SellerID,
		&i.ProductName,
		&i.Description,
		&i.Baseprice,
		&i.AuctionEnd,
		&i.IsSold,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
	)
	return i, err
}

const updateTenant = `-- name: UpdateTenant :one
UPDATE tenants
SET name = $2, plan = $3, status = $4
WHERE id = $1
RETURNING id, name, plan, status, created_at
`

type UpdateTenantParams struct {
	ID     uuid.UUID `json:"id"`
	Name   string    `json:"name"`
	Plan   string    `json:"plan"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateTenant(ctx context.Context, arg UpdateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, updateTenant,
		arg.ID,
		arg.Name,
		arg.Plan,
		arg.Status,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Plan,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET user_name = $2,
    email = $3,
    bio = $4,
    password_hash = $5,
    admin = $6,
    permission_users = $7,
    permission_categoria = $8,
    permission_produto = $9,
    permission_adicional = $10,
    permission_cliente = $11,
    updated_at = now()
WHERE id = $1
RETURNING id, user_name, email, bio, created_at, updated_at, tenant_id, admin, permission_users, permission_categoria, permission_produto, permission_adicional, permission_cliente
`

type UpdateUserParams struct {
	ID                  uuid.UUID   `json:"id"`
	UserName            string      `json:"user_name"`
	Email               string      `json:"email"`
	Bio                 string      `json:"bio"`
	PasswordHash        []byte      `json:"password_hash"`
	Admin               int32       `json:"admin"`
	PermissionUsers     int32       `json:"permission_users"`
	PermissionCategoria pgtype.Int4 `json:"permission_categoria"`
	PermissionProduto   pgtype.Int4 `json:"permission_produto"`
	PermissionAdicional pgtype.Int4 `json:"permission_adicional"`
	PermissionCliente   pgtype.Int4 `json:"permission_cliente"`
}

type UpdateUserRow struct {
	ID                  uuid.UUID   `json:"id"`
	UserName            string      `json:"user_name"`
	Email               string      `json:"email"`
	Bio                 string      `json:"bio"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	TenantID            uuid.UUID   `json:"tenant_id"`
	Admin               int32       `json:"admin"`
	PermissionUsers     int32       `json:"permission_users"`
	PermissionCategoria pgtype.Int4 `json:"permission_categoria"`
	PermissionProduto   pgtype.Int4 `json:"permission_produto"`
	PermissionAdicional pgtype.Int4 `json:"permission_adicional"`
	PermissionCliente   pgtype.Int4 `json:"permission_cliente"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.UserName,
		arg.Email,
		arg.Bio,
		arg.PasswordHash,
		arg.Admin,
		arg.PermissionUsers,
		arg.PermissionCategoria,
		arg.PermissionProduto,
		arg.PermissionAdicional,
		arg.PermissionCliente,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Admin,
		&i.PermissionUsers,
		&i.PermissionCategoria,
		&i.PermissionProduto,
		&i.PermissionAdicional,
		&i.PermissionCliente,
	)
	return i, err
}

const updateUserNoPassword = `-- name: UpdateUserNoPassword :one
UPDATE users
SET user_name = $2,
    email = $3,
    bio = $4,
    admin = $5,
    permission_users = $6,
    permission_categoria = $7,
    permission_produto = $8,
    permission_adicional = $9,
    permission_cliente = $10,
    updated_at = now()
WHERE id = $1
RETURNING id, user_name, email, bio, created_at, updated_at, tenant_id, admin, permission_users, permission_categoria, permission_produto, permission_adicional, permission_cliente
`

type UpdateUserNoPasswordParams struct {
	ID                  uuid.UUID   `json:"id"`
	UserName            string      `json:"user_name"`
	Email               string      `json:"email"`
	Bio                 string      `json:"bio"`
	Admin               int32       `json:"admin"`
	PermissionUsers     int32       `json:"permission_users"`
	PermissionCategoria pgtype.Int4 `json:"permission_categoria"`
	PermissionProduto   pgtype.Int4 `json:"permission_produto"`
	PermissionAdicional pgtype.Int4 `json:"permission_adicional"`
	PermissionCliente   pgtype.Int4 `json:"permission_cliente"`
}

type UpdateUserNoPasswordRow struct {
	ID                  uuid.UUID   `json:"id"`
	UserName            string      `json:"user_name"`
	Email               string      `json:"email"`
	Bio                 string      `json:"bio"`
	CreatedAt           time.Time   `json:"created_at"`
	UpdatedAt           time.Time   `json:"updated_at"`
	TenantID            uuid.UUID   `json:"tenant_id"`
	Admin               int32       `json:"admin"`
	PermissionUsers     int32       `json:"permission_users"`
	PermissionCategoria pgtype.Int4 `json:"permission_categoria"`
	PermissionProduto   pgtype.Int4 `json:"permission_produto"`
	PermissionAdicional pgtype.Int4 `json:"permission_adicional"`
	PermissionCliente   pgtype.Int4 `json:"permission_cliente"`
}

func (q *Queries) UpdateUserNoPassword(ctx context.Context, arg UpdateUserNoPasswordParams) (UpdateUserNoPasswordRow, error) {
	row := q.db.QueryRow(ctx, updateUserNoPassword,
		arg.ID,
		arg.UserName,
		arg.Email,
		arg.Bio,
		arg.Admin,
		arg.PermissionUsers,
		arg.PermissionCategoria,
		arg.PermissionProduto,
		arg.PermissionAdicional,
		arg.PermissionCliente,
	)
	var i UpdateUserNoPasswordRow
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Admin,
		&i.PermissionUsers,
		&i.PermissionCategoria,
		&i.PermissionProduto,
		&i.PermissionAdicional,
		&i.PermissionCliente,
	)
	return i, err
}
