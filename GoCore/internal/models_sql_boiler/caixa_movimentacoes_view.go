// Code generated by SQLBoiler 4.18.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models_sql_boiler

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// CaixaMovimentacoesView is an object representing the database table.
type CaixaMovimentacoesView struct {
	ID               null.String       `boil:"id" json:"id,omitempty" toml:"id" yaml:"id,omitempty"`
	SeqID            null.Int64        `boil:"seq_id" json:"seq_id,omitempty" toml:"seq_id" yaml:"seq_id,omitempty"`
	IDCaixa          null.String       `boil:"id_caixa" json:"id_caixa,omitempty" toml:"id_caixa" yaml:"id_caixa,omitempty"`
	Tipo             null.String       `boil:"tipo" json:"tipo,omitempty" toml:"tipo" yaml:"tipo,omitempty"`
	IDFormaPagamento null.Int16        `boil:"id_forma_pagamento" json:"id_forma_pagamento,omitempty" toml:"id_forma_pagamento" yaml:"id_forma_pagamento,omitempty"`
	Valor            types.NullDecimal `boil:"valor" json:"valor,omitempty" toml:"valor" yaml:"valor,omitempty"`
	Observacao       null.String       `boil:"observacao" json:"observacao,omitempty" toml:"observacao" yaml:"observacao,omitempty"`
	IDPagamento      null.String       `boil:"id_pagamento" json:"id_pagamento,omitempty" toml:"id_pagamento" yaml:"id_pagamento,omitempty"`
	AutorizadoPor    null.String       `boil:"autorizado_por" json:"autorizado_por,omitempty" toml:"autorizado_por" yaml:"autorizado_por,omitempty"`
	CreatedAt        null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt        null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt        null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
}

var CaixaMovimentacoesViewColumns = struct {
	ID               string
	SeqID            string
	IDCaixa          string
	Tipo             string
	IDFormaPagamento string
	Valor            string
	Observacao       string
	IDPagamento      string
	AutorizadoPor    string
	CreatedAt        string
	UpdatedAt        string
	DeletedAt        string
}{
	ID:               "id",
	SeqID:            "seq_id",
	IDCaixa:          "id_caixa",
	Tipo:             "tipo",
	IDFormaPagamento: "id_forma_pagamento",
	Valor:            "valor",
	Observacao:       "observacao",
	IDPagamento:      "id_pagamento",
	AutorizadoPor:    "autorizado_por",
	CreatedAt:        "created_at",
	UpdatedAt:        "updated_at",
	DeletedAt:        "deleted_at",
}

var CaixaMovimentacoesViewTableColumns = struct {
	ID               string
	SeqID            string
	IDCaixa          string
	Tipo             string
	IDFormaPagamento string
	Valor            string
	Observacao       string
	IDPagamento      string
	AutorizadoPor    string
	CreatedAt        string
	UpdatedAt        string
	DeletedAt        string
}{
	ID:               "caixa_movimentacoes_view.id",
	SeqID:            "caixa_movimentacoes_view.seq_id",
	IDCaixa:          "caixa_movimentacoes_view.id_caixa",
	Tipo:             "caixa_movimentacoes_view.tipo",
	IDFormaPagamento: "caixa_movimentacoes_view.id_forma_pagamento",
	Valor:            "caixa_movimentacoes_view.valor",
	Observacao:       "caixa_movimentacoes_view.observacao",
	IDPagamento:      "caixa_movimentacoes_view.id_pagamento",
	AutorizadoPor:    "caixa_movimentacoes_view.autorizado_por",
	CreatedAt:        "caixa_movimentacoes_view.created_at",
	UpdatedAt:        "caixa_movimentacoes_view.updated_at",
	DeletedAt:        "caixa_movimentacoes_view.deleted_at",
}

// Generated where

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var CaixaMovimentacoesViewWhere = struct {
	ID               whereHelpernull_String
	SeqID            whereHelpernull_Int64
	IDCaixa          whereHelpernull_String
	Tipo             whereHelpernull_String
	IDFormaPagamento whereHelpernull_Int16
	Valor            whereHelpertypes_NullDecimal
	Observacao       whereHelpernull_String
	IDPagamento      whereHelpernull_String
	AutorizadoPor    whereHelpernull_String
	CreatedAt        whereHelpernull_Time
	UpdatedAt        whereHelpernull_Time
	DeletedAt        whereHelpernull_Time
}{
	ID:               whereHelpernull_String{field: "\"caixa_movimentacoes_view\".\"id\""},
	SeqID:            whereHelpernull_Int64{field: "\"caixa_movimentacoes_view\".\"seq_id\""},
	IDCaixa:          whereHelpernull_String{field: "\"caixa_movimentacoes_view\".\"id_caixa\""},
	Tipo:             whereHelpernull_String{field: "\"caixa_movimentacoes_view\".\"tipo\""},
	IDFormaPagamento: whereHelpernull_Int16{field: "\"caixa_movimentacoes_view\".\"id_forma_pagamento\""},
	Valor:            whereHelpertypes_NullDecimal{field: "\"caixa_movimentacoes_view\".\"valor\""},
	Observacao:       whereHelpernull_String{field: "\"caixa_movimentacoes_view\".\"observacao\""},
	IDPagamento:      whereHelpernull_String{field: "\"caixa_movimentacoes_view\".\"id_pagamento\""},
	AutorizadoPor:    whereHelpernull_String{field: "\"caixa_movimentacoes_view\".\"autorizado_por\""},
	CreatedAt:        whereHelpernull_Time{field: "\"caixa_movimentacoes_view\".\"created_at\""},
	UpdatedAt:        whereHelpernull_Time{field: "\"caixa_movimentacoes_view\".\"updated_at\""},
	DeletedAt:        whereHelpernull_Time{field: "\"caixa_movimentacoes_view\".\"deleted_at\""},
}

var (
	caixaMovimentacoesViewAllColumns            = []string{"id", "seq_id", "id_caixa", "tipo", "id_forma_pagamento", "valor", "observacao", "id_pagamento", "autorizado_por", "created_at", "updated_at", "deleted_at"}
	caixaMovimentacoesViewColumnsWithoutDefault = []string{}
	caixaMovimentacoesViewColumnsWithDefault    = []string{"id", "seq_id", "id_caixa", "tipo", "id_forma_pagamento", "valor", "observacao", "id_pagamento", "autorizado_por", "created_at", "updated_at", "deleted_at"}
	caixaMovimentacoesViewPrimaryKeyColumns     = []string{}
	caixaMovimentacoesViewGeneratedColumns      = []string{}
)

type (
	// CaixaMovimentacoesViewSlice is an alias for a slice of pointers to CaixaMovimentacoesView.
	// This should almost always be used instead of []CaixaMovimentacoesView.
	CaixaMovimentacoesViewSlice []*CaixaMovimentacoesView
	// CaixaMovimentacoesViewHook is the signature for custom CaixaMovimentacoesView hook methods
	CaixaMovimentacoesViewHook func(context.Context, boil.ContextExecutor, *CaixaMovimentacoesView) error

	caixaMovimentacoesViewQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	caixaMovimentacoesViewType           = reflect.TypeOf(&CaixaMovimentacoesView{})
	caixaMovimentacoesViewMapping        = queries.MakeStructMapping(caixaMovimentacoesViewType)
	caixaMovimentacoesViewInsertCacheMut sync.RWMutex
	caixaMovimentacoesViewInsertCache    = make(map[string]insertCache)
	caixaMovimentacoesViewUpdateCacheMut sync.RWMutex
	caixaMovimentacoesViewUpdateCache    = make(map[string]updateCache)
	caixaMovimentacoesViewUpsertCacheMut sync.RWMutex
	caixaMovimentacoesViewUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var caixaMovimentacoesViewAfterSelectMu sync.Mutex
var caixaMovimentacoesViewAfterSelectHooks []CaixaMovimentacoesViewHook

var caixaMovimentacoesViewBeforeInsertMu sync.Mutex
var caixaMovimentacoesViewBeforeInsertHooks []CaixaMovimentacoesViewHook
var caixaMovimentacoesViewAfterInsertMu sync.Mutex
var caixaMovimentacoesViewAfterInsertHooks []CaixaMovimentacoesViewHook

var caixaMovimentacoesViewBeforeUpsertMu sync.Mutex
var caixaMovimentacoesViewBeforeUpsertHooks []CaixaMovimentacoesViewHook
var caixaMovimentacoesViewAfterUpsertMu sync.Mutex
var caixaMovimentacoesViewAfterUpsertHooks []CaixaMovimentacoesViewHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CaixaMovimentacoesView) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range caixaMovimentacoesViewAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CaixaMovimentacoesView) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range caixaMovimentacoesViewBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CaixaMovimentacoesView) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range caixaMovimentacoesViewAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CaixaMovimentacoesView) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range caixaMovimentacoesViewBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CaixaMovimentacoesView) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range caixaMovimentacoesViewAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCaixaMovimentacoesViewHook registers your hook function for all future operations.
func AddCaixaMovimentacoesViewHook(hookPoint boil.HookPoint, caixaMovimentacoesViewHook CaixaMovimentacoesViewHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		caixaMovimentacoesViewAfterSelectMu.Lock()
		caixaMovimentacoesViewAfterSelectHooks = append(caixaMovimentacoesViewAfterSelectHooks, caixaMovimentacoesViewHook)
		caixaMovimentacoesViewAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		caixaMovimentacoesViewBeforeInsertMu.Lock()
		caixaMovimentacoesViewBeforeInsertHooks = append(caixaMovimentacoesViewBeforeInsertHooks, caixaMovimentacoesViewHook)
		caixaMovimentacoesViewBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		caixaMovimentacoesViewAfterInsertMu.Lock()
		caixaMovimentacoesViewAfterInsertHooks = append(caixaMovimentacoesViewAfterInsertHooks, caixaMovimentacoesViewHook)
		caixaMovimentacoesViewAfterInsertMu.Unlock()
	case boil.BeforeUpsertHook:
		caixaMovimentacoesViewBeforeUpsertMu.Lock()
		caixaMovimentacoesViewBeforeUpsertHooks = append(caixaMovimentacoesViewBeforeUpsertHooks, caixaMovimentacoesViewHook)
		caixaMovimentacoesViewBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		caixaMovimentacoesViewAfterUpsertMu.Lock()
		caixaMovimentacoesViewAfterUpsertHooks = append(caixaMovimentacoesViewAfterUpsertHooks, caixaMovimentacoesViewHook)
		caixaMovimentacoesViewAfterUpsertMu.Unlock()
	}
}

// One returns a single caixaMovimentacoesView record from the query.
func (q caixaMovimentacoesViewQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CaixaMovimentacoesView, error) {
	o := &CaixaMovimentacoesView{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models_sql_boiler: failed to execute a one query for caixa_movimentacoes_view")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CaixaMovimentacoesView records from the query.
func (q caixaMovimentacoesViewQuery) All(ctx context.Context, exec boil.ContextExecutor) (CaixaMovimentacoesViewSlice, error) {
	var o []*CaixaMovimentacoesView

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models_sql_boiler: failed to assign all query results to CaixaMovimentacoesView slice")
	}

	if len(caixaMovimentacoesViewAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CaixaMovimentacoesView records in the query.
func (q caixaMovimentacoesViewQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models_sql_boiler: failed to count caixa_movimentacoes_view rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q caixaMovimentacoesViewQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models_sql_boiler: failed to check if caixa_movimentacoes_view exists")
	}

	return count > 0, nil
}

// CaixaMovimentacoesViews retrieves all the records using an executor.
func CaixaMovimentacoesViews(mods ...qm.QueryMod) caixaMovimentacoesViewQuery {
	mods = append(mods, qm.From("\"caixa_movimentacoes_view\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"caixa_movimentacoes_view\".*"})
	}

	return caixaMovimentacoesViewQuery{q}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CaixaMovimentacoesView) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models_sql_boiler: no caixa_movimentacoes_view provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(caixaMovimentacoesViewColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	caixaMovimentacoesViewInsertCacheMut.RLock()
	cache, cached := caixaMovimentacoesViewInsertCache[key]
	caixaMovimentacoesViewInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			caixaMovimentacoesViewAllColumns,
			caixaMovimentacoesViewColumnsWithDefault,
			caixaMovimentacoesViewColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(caixaMovimentacoesViewType, caixaMovimentacoesViewMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(caixaMovimentacoesViewType, caixaMovimentacoesViewMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"caixa_movimentacoes_view\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"caixa_movimentacoes_view\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to insert into caixa_movimentacoes_view")
	}

	if !cached {
		caixaMovimentacoesViewInsertCacheMut.Lock()
		caixaMovimentacoesViewInsertCache[key] = cache
		caixaMovimentacoesViewInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CaixaMovimentacoesView) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models_sql_boiler: no caixa_movimentacoes_view provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(caixaMovimentacoesViewColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	caixaMovimentacoesViewUpsertCacheMut.RLock()
	cache, cached := caixaMovimentacoesViewUpsertCache[key]
	caixaMovimentacoesViewUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			caixaMovimentacoesViewAllColumns,
			caixaMovimentacoesViewColumnsWithDefault,
			caixaMovimentacoesViewColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			caixaMovimentacoesViewAllColumns,
			caixaMovimentacoesViewPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models_sql_boiler: unable to upsert caixa_movimentacoes_view, could not build update column list")
		}

		ret := strmangle.SetComplement(caixaMovimentacoesViewAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(caixaMovimentacoesViewPrimaryKeyColumns) == 0 {
				return errors.New("models_sql_boiler: unable to upsert caixa_movimentacoes_view, could not build conflict column list")
			}

			conflict = make([]string, len(caixaMovimentacoesViewPrimaryKeyColumns))
			copy(conflict, caixaMovimentacoesViewPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"caixa_movimentacoes_view\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(caixaMovimentacoesViewType, caixaMovimentacoesViewMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(caixaMovimentacoesViewType, caixaMovimentacoesViewMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models_sql_boiler: unable to upsert caixa_movimentacoes_view")
	}

	if !cached {
		caixaMovimentacoesViewUpsertCacheMut.Lock()
		caixaMovimentacoesViewUpsertCache[key] = cache
		caixaMovimentacoesViewUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
