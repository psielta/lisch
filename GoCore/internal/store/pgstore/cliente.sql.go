// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cliente.sql

package pgstore

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countClientesByTenant = `-- name: CountClientesByTenant :one
SELECT COUNT(*)
FROM public.clientes
WHERE tenant_id = $1
`

func (q *Queries) CountClientesByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countClientesByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countClientesPaginated = `-- name: CountClientesPaginated :one
SELECT COUNT(*) 
FROM public.clientes c
WHERE c.tenant_id = $1
  -- Filtro geral
  AND ($2 = '' OR 
       LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($2)) || '%' OR 
       LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($2)) || '%' OR
       c.cpf LIKE '%' || $2 || '%' OR
       c.cnpj LIKE '%' || $2 || '%')
  -- Filtros específicos
  AND ($3 = '' OR LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($3)) || '%')
  AND ($4 = '' OR LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($4)) || '%')
  AND ($5 = '' OR c.cpf = $5)
  AND ($6 = '' OR c.cnpj = $6)
  AND ($7 = '' OR LOWER(unaccent(c.cidade)) LIKE '%' || LOWER(unaccent($7)) || '%')
  AND ($8 = '' OR c.uf = $8)
  AND ($9 = '' OR c.tipo_pessoa = $9)
  AND ($10 = '' OR c.telefone LIKE '%' || $10 || '%')
  AND ($11 = '' OR c.celular LIKE '%' || $11 || '%')
`

type CountClientesPaginatedParams struct {
	TenantID uuid.UUID   `json:"tenant_id"`
	Column2  interface{} `json:"column_2"`
	Column3  interface{} `json:"column_3"`
	Column4  interface{} `json:"column_4"`
	Column5  interface{} `json:"column_5"`
	Column6  interface{} `json:"column_6"`
	Column7  interface{} `json:"column_7"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
	Column11 interface{} `json:"column_11"`
}

func (q *Queries) CountClientesPaginated(ctx context.Context, arg CountClientesPaginatedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countClientesPaginated,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCliente = `-- name: CreateCliente :one

INSERT INTO public.clientes (
    tenant_id,
    tipo_pessoa,
    nome_razao_social,
    nome_fantasia,
    cpf,
    cnpj,
    rg,
    ie,
    im,
    data_nascimento,
    email,
    telefone,
    celular,
    cep,
    logradouro,
    numero,
    complemento,
    bairro,
    cidade,
    uf
) VALUES (
    $1,  $2,  $3,  $4,  $5,  $6,  $7,  $8,  $9, $10,
   $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
)
RETURNING
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at
`

type CreateClienteParams struct {
	TenantID        uuid.UUID   `json:"tenant_id"`
	TipoPessoa      string      `json:"tipo_pessoa"`
	NomeRazaoSocial string      `json:"nome_razao_social"`
	NomeFantasia    pgtype.Text `json:"nome_fantasia"`
	Cpf             pgtype.Text `json:"cpf"`
	Cnpj            pgtype.Text `json:"cnpj"`
	Rg              pgtype.Text `json:"rg"`
	Ie              pgtype.Text `json:"ie"`
	Im              pgtype.Text `json:"im"`
	DataNascimento  pgtype.Date `json:"data_nascimento"`
	Email           pgtype.Text `json:"email"`
	Telefone        pgtype.Text `json:"telefone"`
	Celular         pgtype.Text `json:"celular"`
	Cep             pgtype.Text `json:"cep"`
	Logradouro      pgtype.Text `json:"logradouro"`
	Numero          pgtype.Text `json:"numero"`
	Complemento     pgtype.Text `json:"complemento"`
	Bairro          pgtype.Text `json:"bairro"`
	Cidade          pgtype.Text `json:"cidade"`
	Uf              pgtype.Text `json:"uf"`
}

// ***********************
// CLIENTES
// ***********************
func (q *Queries) CreateCliente(ctx context.Context, arg CreateClienteParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, createCliente,
		arg.TenantID,
		arg.TipoPessoa,
		arg.NomeRazaoSocial,
		arg.NomeFantasia,
		arg.Cpf,
		arg.Cnpj,
		arg.Rg,
		arg.Ie,
		arg.Im,
		arg.DataNascimento,
		arg.Email,
		arg.Telefone,
		arg.Celular,
		arg.Cep,
		arg.Logradouro,
		arg.Numero,
		arg.Complemento,
		arg.Bairro,
		arg.Cidade,
		arg.Uf,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCliente = `-- name: DeleteCliente :exec
DELETE FROM public.clientes
WHERE id = $1
  AND tenant_id = $2
`

type DeleteClienteParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCliente(ctx context.Context, arg DeleteClienteParams) error {
	_, err := q.db.Exec(ctx, deleteCliente, arg.ID, arg.TenantID)
	return err
}

const getCliente = `-- name: GetCliente :one
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at
FROM public.clientes
WHERE id = $1
`

func (q *Queries) GetCliente(ctx context.Context, id uuid.UUID) (Cliente, error) {
	row := q.db.QueryRow(ctx, getCliente, id)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClienteByCNPJ = `-- name: GetClienteByCNPJ :one
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at
FROM public.clientes
WHERE cnpj = $1
  AND tenant_id = $2
`

type GetClienteByCNPJParams struct {
	Cnpj     pgtype.Text `json:"cnpj"`
	TenantID uuid.UUID   `json:"tenant_id"`
}

func (q *Queries) GetClienteByCNPJ(ctx context.Context, arg GetClienteByCNPJParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getClienteByCNPJ, arg.Cnpj, arg.TenantID)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClienteByCPF = `-- name: GetClienteByCPF :one
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at
FROM public.clientes
WHERE cpf = $1
  AND tenant_id = $2
`

type GetClienteByCPFParams struct {
	Cpf      pgtype.Text `json:"cpf"`
	TenantID uuid.UUID   `json:"tenant_id"`
}

func (q *Queries) GetClienteByCPF(ctx context.Context, arg GetClienteByCPFParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, getClienteByCPF, arg.Cpf, arg.TenantID)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listClientesByTenant = `-- name: ListClientesByTenant :many
SELECT
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at
FROM public.clientes
WHERE tenant_id = $1
ORDER BY nome_razao_social
LIMIT  $2 OFFSET $3
`

type ListClientesByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListClientesByTenant(ctx context.Context, arg ListClientesByTenantParams) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, listClientesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cliente
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TipoPessoa,
			&i.NomeRazaoSocial,
			&i.NomeFantasia,
			&i.Cpf,
			&i.Cnpj,
			&i.Rg,
			&i.Ie,
			&i.Im,
			&i.DataNascimento,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.Cep,
			&i.Logradouro,
			&i.Numero,
			&i.Complemento,
			&i.Bairro,
			&i.Cidade,
			&i.Uf,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientesPaginated = `-- name: ListClientesPaginated :many
SELECT
  c.id, c.tenant_id, c.tipo_pessoa, c.nome_razao_social, c.nome_fantasia, c.cpf, c.cnpj, c.rg, c.ie, c.im, c.data_nascimento, c.email, c.telefone, c.celular, c.cep, c.logradouro, c.numero, c.complemento, c.bairro, c.cidade, c.uf, c.created_at, c.updated_at
FROM public.clientes c
WHERE c.tenant_id = $1
  -- Filtro geral (pesquisa em nome/razão social, nome fantasia, cpf, cnpj)
  AND ($5 = '' OR 
       LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($5)) || '%' OR 
       LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($5)) || '%' OR
       c.cpf LIKE '%' || $5 || '%' OR
       c.cnpj LIKE '%' || $5 || '%')
  -- Filtros específicos
  AND ($6 = '' OR LOWER(unaccent(c.nome_razao_social)) LIKE '%' || LOWER(unaccent($6)) || '%')
  AND ($7 = '' OR LOWER(unaccent(c.nome_fantasia)) LIKE '%' || LOWER(unaccent($7)) || '%')
  AND ($8 = '' OR c.cpf = $8)
  AND ($9 = '' OR c.cnpj = $9)
  AND ($10 = '' OR LOWER(unaccent(c.cidade)) LIKE '%' || LOWER(unaccent($10)) || '%')
  AND ($11 = '' OR c.uf = $11)
  AND ($12 = '' OR c.tipo_pessoa = $12)
  AND ($13 = '' OR c.telefone LIKE '%' || $13 || '%')
  AND ($14 = '' OR c.celular LIKE '%' || $14 || '%')
ORDER BY 
  CASE WHEN $3 = 'nome' AND $4 = 'asc' THEN c.nome_razao_social END ASC,
  CASE WHEN $3 = 'nome' AND $4 = 'desc' THEN c.nome_razao_social END DESC,
  CASE WHEN $3 = 'fantasia' AND $4 = 'asc' THEN c.nome_fantasia END ASC,
  CASE WHEN $3 = 'fantasia' AND $4 = 'desc' THEN c.nome_fantasia END DESC,
  CASE WHEN $3 = 'cidade' AND $4 = 'asc' THEN c.cidade END ASC,
  CASE WHEN $3 = 'cidade' AND $4 = 'desc' THEN c.cidade END DESC,
  CASE WHEN $3 = 'data_cadastro' AND $4 = 'asc' THEN c.created_at END ASC,
  CASE WHEN $3 = 'data_cadastro' AND $4 = 'desc' THEN c.created_at END DESC,
  CASE WHEN $3 = 'ultima_atualizacao' AND $4 = 'asc' THEN c.updated_at END ASC,
  CASE WHEN $3 = 'ultima_atualizacao' AND $4 = 'desc' THEN c.updated_at END DESC,
  CASE WHEN $3 = '' THEN c.nome_razao_social END ASC
LIMIT $2 OFFSET $15
`

type ListClientesPaginatedParams struct {
	TenantID uuid.UUID   `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Column3  interface{} `json:"column_3"`
	Column4  interface{} `json:"column_4"`
	Column5  interface{} `json:"column_5"`
	Column6  interface{} `json:"column_6"`
	Column7  interface{} `json:"column_7"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
	Column11 interface{} `json:"column_11"`
	Column12 interface{} `json:"column_12"`
	Column13 interface{} `json:"column_13"`
	Column14 interface{} `json:"column_14"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListClientesPaginated(ctx context.Context, arg ListClientesPaginatedParams) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, listClientesPaginated,
		arg.TenantID,
		arg.Limit,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Column12,
		arg.Column13,
		arg.Column14,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cliente
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TipoPessoa,
			&i.NomeRazaoSocial,
			&i.NomeFantasia,
			&i.Cpf,
			&i.Cnpj,
			&i.Rg,
			&i.Ie,
			&i.Im,
			&i.DataNascimento,
			&i.Email,
			&i.Telefone,
			&i.Celular,
			&i.Cep,
			&i.Logradouro,
			&i.Numero,
			&i.Complemento,
			&i.Bairro,
			&i.Cidade,
			&i.Uf,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCliente = `-- name: UpdateCliente :one
UPDATE public.clientes
SET
    tipo_pessoa        = $3,
    nome_razao_social  = $4,
    nome_fantasia      = $5,
    cpf                = $6,
    cnpj               = $7,
    rg                 = $8,
    ie                 = $9,
    im                 = $10,
    data_nascimento    = $11,
    email              = $12,
    telefone           = $13,
    celular            = $14,
    cep                = $15,
    logradouro         = $16,
    numero             = $17,
    complemento        = $18,
    bairro             = $19,
    cidade             = $20,
    uf                 = $21,
    updated_at         = now()
WHERE id        = $1   -- id do cliente
  AND tenant_id = $2   -- segurança multitenant
RETURNING
    id, tenant_id, tipo_pessoa, nome_razao_social, nome_fantasia, cpf, cnpj, rg, ie, im, data_nascimento, email, telefone, celular, cep, logradouro, numero, complemento, bairro, cidade, uf, created_at, updated_at
`

type UpdateClienteParams struct {
	ID              uuid.UUID   `json:"id"`
	TenantID        uuid.UUID   `json:"tenant_id"`
	TipoPessoa      string      `json:"tipo_pessoa"`
	NomeRazaoSocial string      `json:"nome_razao_social"`
	NomeFantasia    pgtype.Text `json:"nome_fantasia"`
	Cpf             pgtype.Text `json:"cpf"`
	Cnpj            pgtype.Text `json:"cnpj"`
	Rg              pgtype.Text `json:"rg"`
	Ie              pgtype.Text `json:"ie"`
	Im              pgtype.Text `json:"im"`
	DataNascimento  pgtype.Date `json:"data_nascimento"`
	Email           pgtype.Text `json:"email"`
	Telefone        pgtype.Text `json:"telefone"`
	Celular         pgtype.Text `json:"celular"`
	Cep             pgtype.Text `json:"cep"`
	Logradouro      pgtype.Text `json:"logradouro"`
	Numero          pgtype.Text `json:"numero"`
	Complemento     pgtype.Text `json:"complemento"`
	Bairro          pgtype.Text `json:"bairro"`
	Cidade          pgtype.Text `json:"cidade"`
	Uf              pgtype.Text `json:"uf"`
}

func (q *Queries) UpdateCliente(ctx context.Context, arg UpdateClienteParams) (Cliente, error) {
	row := q.db.QueryRow(ctx, updateCliente,
		arg.ID,
		arg.TenantID,
		arg.TipoPessoa,
		arg.NomeRazaoSocial,
		arg.NomeFantasia,
		arg.Cpf,
		arg.Cnpj,
		arg.Rg,
		arg.Ie,
		arg.Im,
		arg.DataNascimento,
		arg.Email,
		arg.Telefone,
		arg.Celular,
		arg.Cep,
		arg.Logradouro,
		arg.Numero,
		arg.Complemento,
		arg.Bairro,
		arg.Cidade,
		arg.Uf,
	)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TipoPessoa,
		&i.NomeRazaoSocial,
		&i.NomeFantasia,
		&i.Cpf,
		&i.Cnpj,
		&i.Rg,
		&i.Ie,
		&i.Im,
		&i.DataNascimento,
		&i.Email,
		&i.Telefone,
		&i.Celular,
		&i.Cep,
		&i.Logradouro,
		&i.Numero,
		&i.Complemento,
		&i.Bairro,
		&i.Cidade,
		&i.Uf,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
